/*! For license information please see lib-backend_util-178f1e34.7ea8694e8e7aed69446a.js.LICENSE.txt */
(self.webpackChunkfractalize=self.webpackChunkfractalize||[]).push([[281],{8075:(t,e,n)=>{"use strict";n.d(e,{$:()=>Fr,A:()=>na,B:()=>ra,C:()=>oa,D:()=>r,E:()=>G,F:()=>sa,G:()=>ia,H:()=>aa,I:()=>la,J:()=>ua,K:()=>o,L:()=>ha,M:()=>ca,N:()=>da,O:()=>ws,P:()=>fa,Q:()=>pa,R:()=>Wo,S:()=>ga,T:()=>jo,U:()=>ma,V:()=>qo,W:()=>ya,X:()=>wa,Y:()=>ba,Z:()=>Ea,_:()=>Dr,a:()=>Co,a$:()=>$e,a0:()=>Nr,a1:()=>Rr,a2:()=>_r,a3:()=>Lr,a4:()=>Or,a5:()=>Pr,a6:()=>It,a7:()=>At,a8:()=>xt,a9:()=>$t,aA:()=>te,aB:()=>ee,aC:()=>ne,aD:()=>re,aE:()=>oe,aF:()=>se,aG:()=>ie,aH:()=>ae,aI:()=>le,aJ:()=>ue,aK:()=>he,aL:()=>ce,aM:()=>de,aN:()=>fe,aO:()=>pe,aP:()=>ge,aQ:()=>me,aR:()=>ye,aS:()=>we,aT:()=>be,aU:()=>Ee,aV:()=>ve,aW:()=>ke,aX:()=>Se,aY:()=>Ie,aZ:()=>Ae,a_:()=>xe,aa:()=>Tt,ab:()=>Mt,ac:()=>Bt,ad:()=>Dt,ae:()=>Ft,af:()=>Nt,ag:()=>Rt,ah:()=>_t,ai:()=>Lt,aj:()=>Ot,ak:()=>Pt,al:()=>Ct,am:()=>Ut,an:()=>zt,ao:()=>jt,ap:()=>qt,aq:()=>Wt,ar:()=>Ht,as:()=>Gt,at:()=>Vt,au:()=>Kt,av:()=>Jt,aw:()=>Zt,ax:()=>Xt,ay:()=>Yt,az:()=>Qt,b:()=>J,b$:()=>Pn,b0:()=>Te,b1:()=>Me,b2:()=>Be,b3:()=>De,b4:()=>Fe,b5:()=>Ne,b6:()=>Re,b7:()=>_e,b8:()=>Le,b9:()=>Oe,bA:()=>cn,bB:()=>dn,bC:()=>fn,bD:()=>pn,bE:()=>gn,bF:()=>mn,bG:()=>yn,bH:()=>wn,bI:()=>bn,bJ:()=>En,bK:()=>vn,bL:()=>kn,bM:()=>Sn,bN:()=>In,bO:()=>An,bP:()=>xn,bQ:()=>$n,bR:()=>Tn,bS:()=>Mn,bT:()=>Bn,bU:()=>Dn,bV:()=>Fn,bW:()=>Nn,bX:()=>Rn,bY:()=>_n,bZ:()=>Ln,b_:()=>On,ba:()=>Pe,bb:()=>Ce,bc:()=>Ue,bd:()=>ze,be:()=>je,bf:()=>qe,bg:()=>We,bh:()=>He,bi:()=>Ge,bj:()=>Ve,bk:()=>Ke,bl:()=>Je,bm:()=>Ze,bn:()=>Xe,bo:()=>Ye,bp:()=>Qe,bq:()=>tn,br:()=>en,bs:()=>nn,bt:()=>rn,bu:()=>on,bv:()=>sn,bw:()=>an,bx:()=>ln,by:()=>un,bz:()=>hn,c:()=>pi,c$:()=>Mi,c0:()=>Cn,c1:()=>Un,c2:()=>zn,c3:()=>jn,c4:()=>qn,c5:()=>Wn,c6:()=>Hn,c7:()=>Gn,c8:()=>Vn,c9:()=>Kn,cA:()=>vr,cB:()=>kr,cC:()=>Sr,cD:()=>Ir,cE:()=>Ar,cF:()=>xr,cG:()=>$r,cH:()=>Tr,cI:()=>Bo,cJ:()=>Zl,cK:()=>ns,cL:()=>Qi,cM:()=>Fi,cN:()=>Li,cO:()=>cs,cP:()=>C,cQ:()=>h,cR:()=>g,cS:()=>H,cT:()=>Bi,cU:()=>Os,cV:()=>As,cW:()=>Ls,cX:()=>vi,cY:()=>Ms,cZ:()=>Is,c_:()=>Ds,ca:()=>Jn,cb:()=>Zn,cc:()=>Xn,cd:()=>Yn,ce:()=>Qn,cf:()=>tr,cg:()=>er,ch:()=>nr,ci:()=>rr,cj:()=>or,ck:()=>sr,cl:()=>ir,cm:()=>ar,cn:()=>lr,co:()=>ur,cp:()=>hr,cq:()=>cr,cr:()=>dr,cs:()=>fr,ct:()=>pr,cu:()=>gr,cv:()=>mr,cw:()=>yr,cx:()=>wr,cy:()=>br,cz:()=>Er,d:()=>gi,d$:()=>$o,d0:()=>$i,d1:()=>Ii,d2:()=>_s,d3:()=>Rs,d4:()=>Ai,d5:()=>hi,d6:()=>li,d7:()=>ci,d8:()=>ui,d9:()=>ms,dA:()=>al,dB:()=>il,dC:()=>Aa,dD:()=>ol,dE:()=>Fa,dF:()=>sl,dG:()=>hl,dH:()=>dl,dI:()=>cl,dJ:()=>y,dK:()=>w,dL:()=>l,dM:()=>us,dN:()=>O,dO:()=>b,dP:()=>Oa,dQ:()=>W,dR:()=>q,dS:()=>z,dT:()=>I,dU:()=>Kl,dV:()=>Ao,dW:()=>Ha,dX:()=>Ji,dY:()=>Zi,dZ:()=>Jl,d_:()=>Io,da:()=>Yo,db:()=>as,dc:()=>d,dd:()=>fs,de:()=>vs,df:()=>T,dg:()=>f,dh:()=>D,di:()=>To,dj:()=>Na,dk:()=>m,dl:()=>ys,dm:()=>Ca,dn:()=>_,dp:()=>c,dq:()=>v,dr:()=>Ga,ds:()=>U,dt:()=>p,du:()=>Sa,dv:()=>k,dw:()=>rl,dx:()=>Qo,dy:()=>Ri,dz:()=>S,e:()=>K,e0:()=>_l,e1:()=>Mo,e2:()=>u,e3:()=>Rl,e4:()=>M,e5:()=>hs,e6:()=>E,e7:()=>bl,e8:()=>Ka,e9:()=>Za,eA:()=>Nl,eB:()=>R,eC:()=>Di,eD:()=>Gl,eE:()=>El,eF:()=>_i,eG:()=>xl,eH:()=>$l,eI:()=>ql,eJ:()=>Yi,eK:()=>Hl,eL:()=>Wl,ea:()=>Va,eb:()=>Ia,ec:()=>Xi,ed:()=>Oi,ee:()=>vl,ef:()=>kl,eg:()=>Sl,eh:()=>Il,ei:()=>Al,ej:()=>$,ek:()=>wl,el:()=>yl,em:()=>Ra,en:()=>xa,eo:()=>Ja,ep:()=>ka,eq:()=>Ol,er:()=>Cl,es:()=>Ul,et:()=>Pl,eu:()=>zl,ev:()=>Tl,ew:()=>Ml,ex:()=>Bl,ey:()=>Dl,ez:()=>Fl,f:()=>mi,g:()=>Es,h:()=>Ua,i:()=>yi,j:()=>tl,k:()=>_a,l:()=>za,m:()=>va,n:()=>el,o:()=>La,p:()=>Ya,q:()=>nl,r:()=>Qa,s:()=>Xo,t:()=>ja,u:()=>Zo,v:()=>ks,w:()=>bs,x:()=>ta,y:()=>ea,z:()=>Xa}),n(3807);class r{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class o{refCount(t){return s("refCount")}incRef(t){return s("incRef")}timerAvailable(){return!0}time(t){return s("time")}read(t){return s("read")}readSync(t){return s("readSync")}numDataIds(){return s("numDataIds")}disposeData(t,e){return s("disposeData")}write(t,e,n){return s("write")}move(t,e,n,r,o){return s("move")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return s("dispose")}}function s(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function i(t){let e=t.length,n=0,r=0;for(;e>0;)r=Math.random()*e|0,e--,n=t[e],t[e]=t[r],t[r]=n}function a(t,e,n){return Math.max(t,Math.min(e,n))}function l(t){return t%2==0?t:t+1}function u(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function h(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function c(t,e,n=""){h(g(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function d(t){h(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function f(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||T(t)&&!n)for(let r=0;r<t.length;++r)f(t[r],e,n);else e.push(t);return e}function p(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function g(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function m(t){return t%1==0}function y(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function w(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function b(t,e=(t=>0),n){return new Promise(((r,o)=>{let s=0;const i=()=>{if(t())return void r();s++;const a=e(s);null!=n&&s>=n?o():setTimeout(i,a)};i()}))}function E(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const o=t.slice();return o[r]=e/n,o}function v(t,e){const n=e.length;return h((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),h(t.every((t=>m(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function k(t,e){const n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||o?null:v(e,t).sort();let i=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[i]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[i]||s[i]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),s[i]<=e&&i++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function S(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function I(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function A(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function x(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function $(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function T(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function M(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function B(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}function D(t){return"string"==typeof t||t instanceof String}function F(t){return"boolean"==typeof t}function N(t){return"number"==typeof t}function R(t){return Array.isArray(t)?R(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":N(t)?"float32":D(t)?"string":F(t)?"bool":"float32"}function _(t){return!!(t&&t.constructor&&t.call&&t.apply)}function L(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function O(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function P(t,e,n,r=!1){const o=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)o[e]=n[t+e]}else{const s=e[0],i=e.slice(1),a=i.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)o[e]=P(t+e*a,i,n,r)}return o}function C(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return P(0,t,e,n)}function U(t,e){const n=z(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function z(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function j(t){t.forEach((e=>{h(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function q(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function W(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function H(t){return t&&t.then&&"function"==typeof t.then}class G{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=V,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(H(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function V(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function K(){return J}let J=null;function Z(){throw new Error("setTimeout has not been defined")}function X(){throw new Error("clearTimeout has not been defined")}var Y,Q=Z,tt=X;function et(t){if(Q===setTimeout)return setTimeout(t,0);if((Q===Z||!Q)&&setTimeout)return Q=setTimeout,setTimeout(t,0);try{return Q(t,0)}catch(e){try{return Q.call(null,t,0)}catch(e){return Q.call(this,t,0)}}}"function"==typeof(Y="undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).setTimeout&&(Q=setTimeout),"function"==typeof Y.clearTimeout&&(tt=clearTimeout);var nt,rt=[],ot=!1,st=-1;function it(){ot&&nt&&(ot=!1,nt.length?rt=nt.concat(rt):st=-1,rt.length&&at())}function at(){if(!ot){var t=et(it);ot=!0;for(var e=rt.length;e;){for(nt=rt,rt=[];++st<e;)nt&&nt[st].run();st=-1,e=rt.length}nt=null,ot=!1,function(t){if(tt===clearTimeout)return clearTimeout(t);if((tt===X||!tt)&&clearTimeout)return tt=clearTimeout,clearTimeout(t);try{tt(t)}catch(e){try{return tt.call(null,t)}catch(e){return tt.call(this,t)}}}(t)}}function lt(t,e){this.fun=t,this.array=e}function ut(){}lt.prototype.run=function(){this.fun.apply(null,this.array)};var ht=ut,ct=ut,dt=ut,ft=ut,pt=ut,gt=ut,mt=ut,yt=Y.performance||{},wt=yt.now||yt.mozNow||yt.msNow||yt.oNow||yt.webkitNow||function(){return(new Date).getTime()},bt=new Date,Et={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];rt.push(new lt(t,e)),1!==rt.length||ot||et(at)},title:"browser",browser:!0,env:{NODE_ENV:"production"},argv:[],version:"",versions:{},on:ht,addListener:ct,once:dt,off:ft,removeListener:pt,removeAllListeners:gt,emit:mt,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*wt.call(yt),n=Math.floor(e),r=Math.floor(e%1*1e9);return t&&(n-=t[0],(r-=t[1])<0&&(n--,r+=1e9)),[n,r]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-bt)/1e3}};let vt;function kt(){if(null==vt){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if(void 0!==Et)t=Et;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}vt=t}return vt}function St(t,e){const n=function(){const t=kt();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const It="Abs",At="Acos",xt="Acosh",$t="Add",Tt="AddN",Mt="All",Bt="Any",Dt="ArgMax",Ft="ArgMin",Nt="Asin",Rt="Asinh",_t="Atan",Lt="Atanh",Ot="Atan2",Pt="AvgPool",Ct="AvgPoolGrad",Ut="AvgPool3D",zt="AvgPool3DGrad",jt="BatchMatMul",qt="BatchToSpaceND",Wt="Bincount",Ht="BroadcastTo",Gt="Cast",Vt="Ceil",Kt="ClipByValue",Jt="Complex",Zt="ComplexAbs",Xt="Concat",Yt="Conv2D",Qt="Conv2DBackpropFilter",te="Conv2DBackpropInput",ee="Conv3D",ne="Conv3DBackpropFilterV2",re="Conv3DBackpropInputV2",oe="Cos",se="Cosh",ie="Cumsum",ae="CropAndResize",le="DenseBincount",ue="DepthToSpace",he="DepthwiseConv2dNative",ce="DepthwiseConv2dNativeBackpropFilter",de="DepthwiseConv2dNativeBackpropInput",fe="Diag",pe="Dilation2D",ge="Dilation2DBackpropInput",me="Dilation2DBackpropFilter",ye="RealDiv",we="Einsum",be="Elu",Ee="EluGrad",ve="Erf",ke="Equal",Se="Exp",Ie="ExpandDims",Ae="Expm1",xe="FFT",$e="Fill",Te="FlipLeftRight",Me="Floor",Be="FloorDiv",De="FusedBatchNorm",Fe="GatherV2",Ne="GatherNd",Re="Greater",_e="GreaterEqual",Le="Identity",Oe="IFFT",Pe="Imag",Ce="IsFinite",Ue="IsInf",ze="IsNan",je="LeakyRelu",qe="Less",We="LessEqual",He="LinSpace",Ge="Log",Ve="Log1p",Ke="LogicalAnd",Je="LogicalNot",Ze="LogicalOr",Xe="LogSoftmax",Ye="LRN",Qe="LRNGrad",tn="Max",en="Maximum",nn="MaxPool",rn="MaxPoolGrad",on="MaxPool3D",sn="MaxPool3DGrad",an="MaxPoolWithArgmax",ln="Mean",un="Min",hn="Minimum",cn="MirrorPad",dn="Mod",fn="Multinomial",pn="Multiply",gn="Neg",mn="NotEqual",yn="NonMaxSuppressionV3",wn="NonMaxSuppressionV4",bn="NonMaxSuppressionV5",En="OnesLike",vn="OneHot",kn="Pack",Sn="PadV2",In="Pool",An="Pow",xn="Prelu",$n="Prod",Tn="Range",Mn="Real",Bn="Reciprocal",Dn="Relu",Fn="Reshape",Nn="ResizeNearestNeighbor",Rn="ResizeNearestNeighborGrad",_n="ResizeBilinear",Ln="ResizeBilinearGrad",On="Relu6",Pn="Reverse",Cn="Round",Un="Rsqrt",zn="ScatterNd",jn="Select",qn="Selu",Wn="Slice",Hn="Sin",Gn="Sinh",Vn="Sign",Kn="Sigmoid",Jn="Softplus",Zn="Sqrt",Xn="Sum",Yn="SpaceToBatchND",Qn="SplitV",tr="Softmax",er="SparseFillEmptyRows",nr="SparseReshape",rr="SparseSegmentMean",or="SparseSegmentSum",sr="SparseToDense",ir="SquaredDifference",ar="Square",lr="StridedSlice",ur="StringNGrams",hr="StringSplit",cr="StringToHashBucketFast",dr="Sub",fr="Tan",pr="Tanh",gr="Tile",mr="TopK",yr="Transform",wr="Transpose",br="Unique",Er="Unpack",vr="UnsortedSegmentSum",kr="ZerosLike",Sr="Step",Ir="FromPixels",Ar="RotateWithOffset",xr="_FusedMatMul",$r="FusedConv2D",Tr="FusedDepthwiseConv2D",Mr=St("kernelRegistry",(()=>new Map)),Br=St("gradRegistry",(()=>new Map));function Dr(t,e){const n=Cr(t,e);return Mr.get(n)}function Fr(t){return Br.get(t)}function Nr(t){const e=Mr.entries(),n=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[s,i]=o,[a]=s.split("_");a===t&&n.push(i)}return n}function Rr(t){const{kernelName:e,backendName:n}=t,r=Cr(e,n);Mr.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Mr.set(r,t)}function _r(t){const{kernelName:e}=t;Br.has(e)&&K().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Br.set(e,t)}function Lr(t,e){const n=Cr(t,e);if(!Mr.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);Mr.delete(n)}function Or(t){if(!Br.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);Br.delete(t)}function Pr(t,e){Nr(t).forEach((t=>{Rr(Object.assign({},t,{backendName:e}))}))}function Cr(t,e){return`${e}_${t}`}var Ur=jr,zr=null;try{zr=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function jr(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function qr(t){return!0===(t&&t.__isLong__)}jr.prototype.__isLong__,Object.defineProperty(jr.prototype,"__isLong__",{value:!0}),jr.isLong=qr;var Wr={},Hr={};function Gr(t,e){var n,r,o;return e?(o=0<=(t>>>=0)&&t<256)&&(r=Hr[t])?r:(n=Kr(t,(0|t)<0?-1:0,!0),o&&(Hr[t]=n),n):(o=-128<=(t|=0)&&t<128)&&(r=Wr[t])?r:(n=Kr(t,t<0?-1:0,!1),o&&(Wr[t]=n),n)}function Vr(t,e){if(isNaN(t))return e?ro:no;if(e){if(t<0)return ro;if(t>=Qr)return lo}else{if(t<=-to)return uo;if(t+1>=to)return ao}return t<0?Vr(-t,e).neg():Kr(t%Yr|0,t/Yr|0,e)}function Kr(t,e,n){return new jr(t,e,n)}jr.fromInt=Gr,jr.fromNumber=Vr,jr.fromBits=Kr;var Jr=Math.pow;function Zr(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return no;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return Zr(t.substring(1),e,n).neg();for(var o=Vr(Jr(n,8)),s=no,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),l=parseInt(t.substring(i,i+a),n);if(a<8){var u=Vr(Jr(n,a));s=s.mul(u).add(Vr(l))}else s=(s=s.mul(o)).add(Vr(l))}return s.unsigned=e,s}function Xr(t,e){return"number"==typeof t?Vr(t,e):"string"==typeof t?Zr(t,e):Kr(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}jr.fromString=Zr,jr.fromValue=Xr;var Yr=4294967296,Qr=Yr*Yr,to=Qr/2,eo=Gr(1<<24),no=Gr(0);jr.ZERO=no;var ro=Gr(0,!0);jr.UZERO=ro;var oo=Gr(1);jr.ONE=oo;var so=Gr(1,!0);jr.UONE=so;var io=Gr(-1);jr.NEG_ONE=io;var ao=Kr(-1,2147483647,!1);jr.MAX_VALUE=ao;var lo=Kr(-1,-1,!0);jr.MAX_UNSIGNED_VALUE=lo;var uo=Kr(0,-2147483648,!1);jr.MIN_VALUE=uo;var ho=jr.prototype;ho.toInt=function(){return this.unsigned?this.low>>>0:this.low},ho.toNumber=function(){return this.unsigned?(this.high>>>0)*Yr+(this.low>>>0):this.high*Yr+(this.low>>>0)},ho.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(uo)){var e=Vr(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var o=Vr(Jr(t,6),this.unsigned),s=this,i="";;){var a=s.div(o),l=(s.sub(a.mul(o)).toInt()>>>0).toString(t);if((s=a).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},ho.getHighBits=function(){return this.high},ho.getHighBitsUnsigned=function(){return this.high>>>0},ho.getLowBits=function(){return this.low},ho.getLowBitsUnsigned=function(){return this.low>>>0},ho.getNumBitsAbs=function(){if(this.isNegative())return this.eq(uo)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},ho.isZero=function(){return 0===this.high&&0===this.low},ho.eqz=ho.isZero,ho.isNegative=function(){return!this.unsigned&&this.high<0},ho.isPositive=function(){return this.unsigned||this.high>=0},ho.isOdd=function(){return 1==(1&this.low)},ho.isEven=function(){return 0==(1&this.low)},ho.equals=function(t){return qr(t)||(t=Xr(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},ho.eq=ho.equals,ho.notEquals=function(t){return!this.eq(t)},ho.neq=ho.notEquals,ho.ne=ho.notEquals,ho.lessThan=function(t){return this.comp(t)<0},ho.lt=ho.lessThan,ho.lessThanOrEqual=function(t){return this.comp(t)<=0},ho.lte=ho.lessThanOrEqual,ho.le=ho.lessThanOrEqual,ho.greaterThan=function(t){return this.comp(t)>0},ho.gt=ho.greaterThan,ho.greaterThanOrEqual=function(t){return this.comp(t)>=0},ho.gte=ho.greaterThanOrEqual,ho.ge=ho.greaterThanOrEqual,ho.compare=function(t){if(qr(t)||(t=Xr(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},ho.comp=ho.compare,ho.negate=function(){return!this.unsigned&&this.eq(uo)?uo:this.not().add(oo)},ho.neg=ho.negate,ho.add=function(t){qr(t)||(t=Xr(t));var e=this.high>>>16,n=65535&this.high,r=this.low>>>16,o=65535&this.low,s=t.high>>>16,i=65535&t.high,a=t.low>>>16,l=0,u=0,h=0,c=0;return h+=(c+=o+(65535&t.low))>>>16,u+=(h+=r+a)>>>16,l+=(u+=n+i)>>>16,l+=e+s,Kr((h&=65535)<<16|(c&=65535),(l&=65535)<<16|(u&=65535),this.unsigned)},ho.subtract=function(t){return qr(t)||(t=Xr(t)),this.add(t.neg())},ho.sub=ho.subtract,ho.multiply=function(t){if(this.isZero())return no;if(qr(t)||(t=Xr(t)),zr)return Kr(zr.mul(this.low,this.high,t.low,t.high),zr.get_high(),this.unsigned);if(t.isZero())return no;if(this.eq(uo))return t.isOdd()?uo:no;if(t.eq(uo))return this.isOdd()?uo:no;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(eo)&&t.lt(eo))return Vr(this.toNumber()*t.toNumber(),this.unsigned);var e=this.high>>>16,n=65535&this.high,r=this.low>>>16,o=65535&this.low,s=t.high>>>16,i=65535&t.high,a=t.low>>>16,l=65535&t.low,u=0,h=0,c=0,d=0;return c+=(d+=o*l)>>>16,h+=(c+=r*l)>>>16,c&=65535,h+=(c+=o*a)>>>16,u+=(h+=n*l)>>>16,h&=65535,u+=(h+=r*a)>>>16,h&=65535,u+=(h+=o*i)>>>16,u+=e*l+n*a+r*i+o*s,Kr((c&=65535)<<16|(d&=65535),(u&=65535)<<16|(h&=65535),this.unsigned)},ho.mul=ho.multiply,ho.divide=function(t){if(qr(t)||(t=Xr(t)),t.isZero())throw Error("division by zero");var e,n,r;if(zr)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?Kr((this.unsigned?zr.div_u:zr.div_s)(this.low,this.high,t.low,t.high),zr.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ro:no;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return ro;if(t.gt(this.shru(1)))return so;r=ro}else{if(this.eq(uo))return t.eq(oo)||t.eq(io)?uo:t.eq(uo)?oo:(e=this.shr(1).div(t).shl(1)).eq(no)?t.isNegative()?oo:io:(n=this.sub(t.mul(e)),r=e.add(n.div(t)));if(t.eq(uo))return this.unsigned?ro:no;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();r=no}for(n=this;n.gte(t);){e=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(e)/Math.LN2),s=o<=48?1:Jr(2,o-48),i=Vr(e),a=i.mul(t);a.isNegative()||a.gt(n);)a=(i=Vr(e-=s,this.unsigned)).mul(t);i.isZero()&&(i=oo),r=r.add(i),n=n.sub(a)}return r},ho.div=ho.divide,ho.modulo=function(t){return qr(t)||(t=Xr(t)),zr?Kr((this.unsigned?zr.rem_u:zr.rem_s)(this.low,this.high,t.low,t.high),zr.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},ho.mod=ho.modulo,ho.rem=ho.modulo,ho.not=function(){return Kr(~this.low,~this.high,this.unsigned)},ho.and=function(t){return qr(t)||(t=Xr(t)),Kr(this.low&t.low,this.high&t.high,this.unsigned)},ho.or=function(t){return qr(t)||(t=Xr(t)),Kr(this.low|t.low,this.high|t.high,this.unsigned)},ho.xor=function(t){return qr(t)||(t=Xr(t)),Kr(this.low^t.low,this.high^t.high,this.unsigned)},ho.shiftLeft=function(t){return qr(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?Kr(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Kr(0,this.low<<t-32,this.unsigned)},ho.shl=ho.shiftLeft,ho.shiftRight=function(t){return qr(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?Kr(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Kr(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},ho.shr=ho.shiftRight,ho.shiftRightUnsigned=function(t){if(qr(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?Kr(this.low>>>t|e<<32-t,e>>>t,this.unsigned):Kr(32===t?e:e>>>t-32,0,this.unsigned)},ho.shru=ho.shiftRightUnsigned,ho.shr_u=ho.shiftRightUnsigned,ho.toSigned=function(){return this.unsigned?Kr(this.low,this.high,!1):this},ho.toUnsigned=function(){return this.unsigned?this:Kr(this.low,this.high,!0)},ho.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},ho.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},ho.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},jr.fromBytes=function(t,e,n){return n?jr.fromBytesLE(t,e):jr.fromBytesBE(t,e)},jr.fromBytesLE=function(t,e){return new jr(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},jr.fromBytesBE=function(t,e){return new jr(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)};const co=Ur||Object.freeze(Object.assign(Object.create(null),Ur,{default:Ur}));function fo(t){return co.fromString(t,!0,16)}const po=fo("c3a5c85c97cb3127"),go=fo("b492b66fbe98f273"),mo=fo("9ae16a3b2f90404f");function yo(t){return t.xor(t.shru(47))}function wo(t,e,n){const r=t.slice(e,e+n);return co.fromBytes(Array.from(r),!0,!0)}function bo(t,e){return wo(t,e,8)}function Eo(t,e){return wo(t,e,4)}function vo(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function ko(t,e,n=fo("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let o=e.xor(r).mul(n);return o=o.xor(o.shru(47)),o=o.mul(n),o}function So(t,e,n,r){return function(t,e,n,r,o,s){o=o.add(t),s=vo(s.add(o).add(r),21);const i=o;return o=(o=o.add(e)).add(n),s=s.add(vo(o,44)),[o.add(r),s.add(i)]}(bo(t,e),bo(t,e+8),bo(t,e+16),bo(t,e+24),n,r)}function Io(t,e=t.length){const n=co.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=mo.add(2*e),r=bo(t,0).add(mo),o=bo(t,e-8);return ko(vo(o,37).mul(n).add(r),vo(r,25).add(o).mul(n),n)}if(e>=4){const n=mo.add(2*e);return ko(Eo(t,0).shl(3).add(e),Eo(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return yo(mo.mul(n).xor(po.mul(r))).mul(mo)}return mo}(t,e):function(t,e=t.length){const n=mo.add(2*e),r=bo(t,0).mul(go),o=bo(t,8),s=bo(t,e-8).mul(n),i=bo(t,e-16).mul(mo);return ko(vo(r.add(o),43).add(vo(s,30)).add(i),r.add(vo(o.add(mo),18)).add(s),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=mo.add(2*e),r=bo(t,0).mul(mo),o=bo(t,8),s=bo(t,e-8).mul(n),i=bo(t,e-16).mul(mo),a=vo(r.add(o),43).add(vo(s,30)).add(i),l=ko(a,r.add(vo(o.add(mo),18)).add(s),n),u=bo(t,16).mul(n),h=bo(t,24),c=a.add(bo(t,e-32)).mul(n),d=l.add(bo(t,e-24)).mul(n);return ko(vo(u.add(h),43).add(vo(c,30)).add(d),u.add(vo(h.add(r),18)).add(c),n)}(t,e);let r=n,o=n.mul(go).add(113),s=yo(o.mul(mo).add(113)).mul(mo),i=[co.UZERO,co.UZERO],a=[co.UZERO,co.UZERO];r=r.mul(mo).add(bo(t,0));let l=0;const u=64*(e-1>>6),h=u+(e-1&63)-63;do{r=vo(r.add(o).add(i[0]).add(bo(t,l+8)),37).mul(go),o=vo(o.add(i[1]).add(bo(t,l+48)),42).mul(go),r=r.xor(a[1]),o=o.add(i[0]).add(bo(t,l+40)),s=vo(s.add(a[0]),33).mul(go),i=So(t,l,i[1].mul(go),r.add(a[0])),a=So(t,l+32,s.add(a[1]),o.add(bo(t,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const c=go.add(s.and(255).shl(1));return l=h,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=vo(r.add(o).add(i[0]).add(bo(t,l+8)),37).mul(c),o=vo(o.add(i[1]).add(bo(t,l+48)),42).mul(c),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(bo(t,l+40))),s=vo(s.add(a[0]),33).mul(c),i=So(t,l,i[1].mul(c),r.add(a[0])),a=So(t,l+32,s.add(a[1]),o.add(bo(t,l+16))),[s,r]=[r,s],ko(ko(i[0],a[0],c).add(yo(o).mul(po)).add(s),ko(i[1],a[1],c).add(r),c)}function Ao(t,e){return"string"===e?To(t):xo([t],e)}function xo(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=f(t)),K().getBool("DEBUG")&&A(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function $o(){return K().platform.now()}function To(t,e="utf-8"){return e=e||"utf-8",K().platform.encode(t,e)}function Mo(t,e="utf-8"){return e=e||"utf-8",K().platform.decode(t,e)}var Bo=Object.freeze({__proto__:null,createScalarValue:Ao,toTypedArray:xo,now:$o,fetch:function(t,e){return K().platform.fetch(t,e)},encodeString:To,decodeString:Mo,shuffle:i,shuffleCombo:function(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n,r,o=t.length,s=0;for(;o>0;)s=Math.random()*o|0,o--,n=t[o],r=e[o],t[o]=t[s],e[o]=e[s],t[s]=n,e[s]=r},clamp:a,nearestLargerEven:l,sum:u,randUniform:function(t,e){const n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){let n=0;for(let r=0;r<t.length;r++){const o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:h,assertShapesMatch:c,assertNonNull:d,flatten:f,sizeFromShape:p,isScalarShape:function(t){return 0===t.length},arraysEqual:g,isInt:m,tanh:function(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}},sizeToSquarishShape:y,createShuffledIndices:function(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return i(e),e},rightPad:w,repeatedTry:b,inferFromImplicitShape:E,parseAxisParam:v,squeezeShape:k,getTypedArrayFromDType:S,getArrayFromDType:I,checkConversionForErrors:A,isValidDtype:x,hasEncodingLoss:$,isTypedArray:T,bytesPerElement:M,bytesFromStringArray:B,isString:D,isBoolean:F,isNumber:N,inferDtype:R,isFunction:_,nearestDivisor:L,computeStrides:O,toNestedArray:C,makeOnesTypedArray:U,makeZerosTypedArray:z,makeZerosNestedTypedArray:function(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return C(t,new Float32Array(n));if("int32"===e)return C(t,new Int32Array(n));if("bool"===e)return C(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)},assertNonNegativeIntegerDimensions:j,locToIndex:q,indexToLoc:W,isPromise:H,hexToLong:fo,fingerPrint64:Io});class Do{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new No)}profileKernel(t,e,n){let r;const o=()=>{r=n()};let s;const i=$o();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(o);else{o();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:$o()-i})}if(K().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{Fo(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:o,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],o,n[2])}))}))}}function Fo(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class No{logKernelProfile(t,e,n,r,o,s){const i="number"==typeof r?w(`${r}ms`,9):r.error,a=w(t,25),l=e.rank,u=e.size,h=w(e.shape.toString(),14);let c="";for(const t in o){const n=o[t];if(null!=n){const r=n.shape||e.shape,o=r.length;c+=`${t}: ${o}D ${o>0?r:""} `}}console.log(`%c${a}\t%c${i}\t%c${l}D ${h}\t%c${u}\t%c${c}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Ro(t,e,n,r){const o=O(e),s=function(t,e,n,r){const o=p(e),s=r[r.length-1],i=new Array(s).fill(0),a=e.length,l="complex64"===n?Po(t):t;if(a>1)for(let t=0;t<o/s;t++){const e=t*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],_o(l[e+t],0,n).length)}return i}(t,e,n,o),i=e.length,a=Oo(t,e,n,o,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map((t=>"    "+t)).join("\n")),l.join("\n")}function _o(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:D(t)?`'${t}'`:"bool"===n?Lo(t):parseFloat(t.toFixed(7)).toString(),w(r,e)}function Lo(t){return 0===t?"false":"true"}function Oo(t,e,n,r,o,s=!0){const i="complex64"===n?2:1,a=e[0],l=e.length;if(0===l)return"complex64"===n?[_o(Po(t)[0],0,n)]:"bool"===n?[Lo(t[0])]:[t[0].toString()];if(1===l){if(a>20){const e=3*i;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((a-3)*i,a*i));return"complex64"===n&&(r=Po(r),s=Po(s)),["["+r.map(((t,e)=>_o(t,o[e],n))).join(", ")+", ..., "+s.map(((t,e)=>_o(t,o[a-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Po(t):Array.from(t)).map(((t,e)=>_o(t,o[e],n))).join(", ")+"]"]}const u=e.slice(1),h=r.slice(1),c=r[0]*i,d=[];if(a>20){for(let e=0;e<3;e++){const r=e*c,s=r+c;d.push(...Oo(t.slice(r,s),u,n,h,o,!1))}d.push("...");for(let e=a-3;e<a;e++){const r=e*c,s=r+c;d.push(...Oo(t.slice(r,s),u,n,h,o,e===a-1))}}else for(let e=0;e<a;e++){const r=e*c,s=r+c;d.push(...Oo(t.slice(r,s),u,n,h,o,e===a-1))}const f=2===l?",":"";d[0]="["+d[0]+f;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+f;let p=",\n";for(let t=2;t<l;t++)p+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":p),d}function Po(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Co{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=p(t),null!=n){const t=n.length;h(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||I(e,this.size),this.strides=O(t)}set(t,...e){0===e.length&&(e=[0]),h(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Uo().makeTensor(this.values,this.shape,this.dtype)}}let Uo=null,zo=null;class jo{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=p(t),this.strides=O(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return zo.buffer(this.shape,this.dtype,t)}bufferSync(){return zo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return C(this.shape,t,"complex64"===this.dtype)}arraySync(){return C(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Uo().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>Mo(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Uo().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>Mo(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Uo().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Uo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return zo.print(this,t)}clone(){return this.throwIfDisposed(),zo.clone(this)}toString(t=!1){return Ro(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),zo.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Uo().makeVariable(this,t,e,n)}}Object.defineProperty(jo,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),St("Tensor",(()=>jo));class qo extends jo{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!g(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Uo().disposeTensor(this),this.dataId=t.dataId,Uo().incRef(this,null)}dispose(){Uo().disposeVariable(this),this.isDisposedInternal=!0}}var Wo,Ho,Go,Vo,Ko;Object.defineProperty(qo,Symbol.hasInstance,{value:t=>t instanceof jo&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Wo||(Wo={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Ho||(Ho={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Go||(Go={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Vo||(Vo={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Ko||(Ko={}));const Jo={float32:Vo,int32:Ho,bool:Go,complex64:Ko};function Zo(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Jo[t][e]}function Xo(t){return Zo(t,"int32")}function Yo(t,e){if(t.dtype===e.dtype)return[t,e];const n=Zo(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Qo(t,e){h(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function ts(t){const e=[];return es(t,e,new Set),e}function es(t,e,n){if(null==t)return;if(t instanceof jo)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const o=t;for(const t in o){const r=o[t];n.has(r)||(n.add(r),es(r,e,n))}}var ns=Object.freeze({__proto__:null,makeTypesMatch:Yo,assertTypesMatch:Qo,isTensorInList:function(t,e){return e.some((e=>e.id===t.id))},getTensorsInContainer:ts});function rs(t){return null!=t.kernelName}class os{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ss{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new os}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Do(this.backendInstance),!0}setupRegisteredKernels(){Nr(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Nr(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof o||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:o}=this.initializeBackend(n);if(o||r)return{name:n,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,o,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return ss.nextTensorId++}nextVariableId(){return ss.nextVariableId++}clone(t){const e=as.runKernel(Le,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t};return as.runKernel(Gt,e,{dtype:"float32"})}})),[],{}),e}runKernel(t,e,n){if(null==Dr(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let o=0;n.forEach((t=>{o+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-o-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),o=this.state.numBytes,s=this.state.numTensors;let i,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=rs(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(rs(t)){const{kernelName:e,inputs:o,attrs:s}=t;null==this.backendName&&this.backend;const l=Dr(e,this.backendName);h(null!=l,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),i=()=>{const t=this.backend.numDataIds();a=l.kernelFunc({inputs:o,attrs:s,backend:this.backend});const i=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,i);const u=i.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(r){const t=this.getTensorsForGradient(e,o,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,o=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};i=()=>{const t=this.backend.numDataIds();a=this.tidy((()=>e(this.backend,o)));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,d=rs(t)?null:t.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs):e=i()})),r&&this.addTapeNode(l,u,e,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(a)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=Fr(t);if(null!=r){const t=r.inputsToSave||[],o=r.outputsToSave||[];let s;r.saveAllInputs?(h(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const i=n.filter(((t,e)=>o[e]));return s.concat(i)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=t;"string"===n&&D(t[0])&&(o=t.map((t=>To(t))));const s=r.write(o,e,n),i=new jo(e,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const t=this.state.tensorInfo.get(s),e=B(o);this.state.numBytes+=e-t.bytes,t.bytes=e}return i}makeTensorFromDataId(t,e,n,r){const o=new jo(e,n=n||"float32",t,this.nextTensorId());return this.trackTensor(o,r),o}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const o=new qo(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*M(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof qo||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*M(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,o,s){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},a=Fr(t);null!=a&&(r=a.gradFunc),null!=r&&(i.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=z(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],o,s))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=ts(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(h(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));h(o instanceof jo,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},o={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],i=s.inputs;for(const t in i){const n=i[t];let a=!1;for(let t=0;t<e.length;t++)if(r[n.id]){s.outputs.forEach((t=>r[t.id]=!0)),a=!0,o[s.id]=!0;break}if(a)break}}const s={};s[n.id]=!0;const i={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in r)s[r[t].id]=!0,i[n.id]=!0;break}}const a=[];for(let e=0;e<t.length;e++){const n=t[e];if(o[n.id]&&i[n.id]){const t={};for(const e in n.inputs){const o=n.inputs[e];r[o.id]&&(t[e]=o)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,a.push(e)}}return a}(this.state.activeTape,e,o);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[o.id]=null==n?function(t){const e=U(p(t),"float32");return as.makeTensor(e,t,"float32")}(o.shape):n,function(t,e,n,r){for(let o=e.length-1;o>=0;o--){const s=e[o],i=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(i);for(const e in s.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const o=n((()=>a[e]()));if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${o.dtype}'`);const i=s.inputs[e];if(!g(o.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${o.shape}', which does not match the shape of the input '${i.shape}'`);if(null==t[i.id])t[i.id]=o;else{const e=t[i.id];t[i.id]=r(e,o),e.dispose()}}}}(t,s,(t=>this.tidy(t)),ls);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(t){return h(_(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;h(e.every((t=>t instanceof jo)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((t,e)=>{r[e]=t})),this.runKernelFunc({forwardFunc:(r,o)=>(n=t(...e,o),h(n.value instanceof jo,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),h(_(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const o=n.gradFunc(t,r),s=Array.isArray(o)?o:[o];h(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),h(s.every((t=>t instanceof jo)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((t,e)=>{i[e]=()=>t})),i},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=$o(),n=await this.backend.time(t);return n.wallMs=$o()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new os;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function is(){const t=kt();if(null==t._tfengine){const e=new G(t);t._tfengine=new ss(e)}var e;return e=t._tfengine.ENV,J=e,Uo=()=>t._tfengine,t._tfengine}ss.nextTensorId=0,ss.nextVariableId=0;const as=is();function ls(t,e){const n={a:t,b:e};return as.runKernel($t,n)}function us(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function hs(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var cs=Object.freeze({__proto__:null,isMobile:us,isBrowser:hs});const ds=K();function fs(t,e){let n=t;if(T(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||T(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&K().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ps(t,r,[]),r}function ps(t,e,n){if(n=n||[],!Array.isArray(t)&&!T(t))return void h(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));h(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),h(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)ps(t[e],r,n.concat(e))}function gs(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function ms(t,e,n,r="numeric"){if(t instanceof jo)return gs(r,t.dtype,e,n),t;let o=R(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),gs(r,o,e,n),null==t||!T(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=fs(t,o);T(t)||Array.isArray(t)||(t=[t]);const i="string"!==o?xo(t,o):f(t,[],!0);return as.makeTensor(i,s,o)}function ys(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,o)=>ms(t,`${e}[${o}]`,n,r)))}ds.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ds.registerFlag("IS_BROWSER",(()=>hs())),ds.registerFlag("IS_NODE",(()=>void 0!==Et&&void 0!==Et.versions&&void 0!==Et.versions.node)),ds.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ds.registerFlag("PROD",(()=>!1)),ds.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ds.getBool("DEBUG"))),ds.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ds.registerFlag("IS_TEST",(()=>!1)),ds.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),ds.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1));const ws="__op";function bs(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=ws;const o=(...t)=>{as.startScope(n);try{const e=r(...t);return H(e)&&console.error("Cannot return a Promise inside of tidy."),as.endScope(e),e}catch(t){throw as.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}const Es=bs({complex_:function(t,e){const n=ms(t,"real","complex"),r=ms(e,"imag","complex");c(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const o={real:n,imag:r};return as.runKernel(Jt,o)}});function vs(t,e,n,r){if(null==r&&(r=R(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!T(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){j(e);const t=p(e),r=p(n);h(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],o=t!==n.length-1||r!==p(e.slice(t));h(n[t]===e[t]||!o,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return T(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?xo(t,r):f(t,[],!0),as.makeTensor(t,e,r)}function ks(t,e,n){return vs(t,e,fs(t,n),n)}const Ss={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function Is(t,e){const n=[],r=[],o=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<o.length;++s){const i=o[s],a=Array.isArray(t)?t[s].tensor:t[i];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${a.dtype}`);const l={name:i,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise((async t=>{const e=await a.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+4*e.length,r=new Uint8Array(n);let o=0;for(let t=0;t<e.length;t++){const n=e[t],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,o),o+=4,r.set(n,o),o+=n.length}t(r)}));r.push(t)}else r.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:xs(await Promise.all(r)),specs:n}}function As(t,e){const n={};let r,o=0;for(const s of e){const e=s.name,i=s.dtype,a=s.shape,l=p(a);let u;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const a=Ss[n.dtype],h=t.slice(o,o+l*a),c="uint8"===n.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];u[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=Fs()),u=r(c)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${e}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(c.length);for(let t=0;t<c.length;t++){const e=c[t];u[t]=Math.round(e*n.scale+n.min)}}o+=l*a}else if("string"===i){const e=p(s.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(o,o+4))[0];o+=4;const n=new Uint8Array(t.slice(o,o+e));u.push(n),o+=e}}else{const r=Ss[i],s=t.slice(o,o+l*r);if("float32"===i)u=new Float32Array(s);else if("int32"===i)u=new Int32Array(s);else if("bool"===i)u=new Uint8Array(s);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${e}': ${i}`);{u=new Float32Array(s);const t=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],r[e]=u[2*e+1];const o=ks(t,a,"float32"),i=ks(r,a,"float32");n[e]=Es(o,i),o.dispose(),i.dispose()}}o+=l*r}"complex64"!==i&&(n[e]=ks(u,a,i))}return n}function xs(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let o=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),o),o+=t.byteLength})),r.buffer}const $s="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Ts(t){return $s?Buffer.byteLength(t):new Blob([t]).size}function Ms(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Bs(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function Ds(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Ts(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Ts(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function Fs(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let o=0;o<r.length;o++){const i=r[o],a=t[n[i>>10]+(1023&i)]+e[i>>10];s[o]=a}return new Float32Array(o)}}class Ns{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ns.instance&&(Ns.instance=new Ns),Ns.instance}static registerSaveRouter(t){Ns.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ns.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ns.getHandlers(t,"save")}static getLoadHandlers(t,e){return Ns.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?Ns.getInstance().loadRouters:Ns.getInstance().saveRouters).forEach((e=>{const o=e(t,n);null!==o&&r.push(o)})),r}}const Rs=t=>Ns.registerSaveRouter(t),_s=t=>Ns.registerLoadRouter(t),Ls=t=>Ns.getSaveHandlers(t),Os=(t,e)=>Ns.getLoadHandlers(t,e),Ps="tensorflowjs",Cs="models_store",Us="model_info_store";function zs(){if(!K().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function js(t){const e=t.result;e.createObjectStore(Cs,{keyPath:"modelPath"}),e.createObjectStore(Us,{keyPath:"modelPath"})}class qs{constructor(t){if(this.indexedDB=zs(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(Ps,1);r.onupgradeneeded=()=>js(r),r.onsuccess=()=>{const o=r.result;if(null==e){const e=o.transaction(Cs,"readonly"),r=e.objectStore(Cs).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(o.close(),n(r.error)),e.oncomplete=()=>o.close()}else{const r=Ds(e),s=o.transaction(Us,"readwrite");let i=s.objectStore(Us);const a=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;a.onsuccess=()=>{l=o.transaction(Cs,"readwrite");const a=l.objectStore(Cs).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{i=s.objectStore(Us);const e=i.delete(this.modelPath);e.onsuccess=()=>(o.close(),n(a.error)),e.onerror=t=>(o.close(),n(a.error))}},a.onerror=t=>(o.close(),n(a.error)),s.oncomplete=()=>{null==l?o.close():l.oncomplete=()=>o.close()}}},r.onerror=t=>n(r.error)}))}}qs.URL_SCHEME="indexeddb://";const Ws=t=>{return K().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(qs.URL_SCHEME)?(e=t.slice(qs.URL_SCHEME.length),new qs(e)):null;var e};Ns.registerSaveRouter(Ws),Ns.registerLoadRouter(Ws);class Hs{constructor(){this.indexedDB=zs()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(Ps,1);n.onupgradeneeded=()=>js(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(Us,"readonly"),s=o.objectStore(Us).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),o.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(qs.URL_SCHEME)?e.slice(qs.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(Ps,1);r.onupgradeneeded=()=>js(r),r.onsuccess=()=>{const o=r.result,s=o.transaction(Us,"readwrite"),i=s.objectStore(Us),a=i.get(t);let l;a.onsuccess=()=>{if(null==a.result)return o.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=i.delete(t),s=()=>{l=o.transaction(Cs,"readwrite");const r=l.objectStore(Cs).delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=s,r.onerror=t=>(s(),o.close(),n(a.error))}},a.onerror=t=>(o.close(),n(a.error)),s.oncomplete=()=>{null==l?o.close():l.oncomplete=()=>o.close()}},r.onerror=t=>n(r.error)}))}}const Gs="/",Vs="tensorflowjs_models",Ks="info",Js="model_topology",Zs="weight_specs",Xs="weight_data",Ys="model_metadata";function Qs(t){return{info:[Vs,t,Ks].join(Gs),topology:[Vs,t,Js].join(Gs),weightSpecs:[Vs,t,Zs].join(Gs),weightData:[Vs,t,Xs].join(Gs),modelMetadata:[Vs,t,Ys].join(Gs)}}function ti(t){const e=t.split(Gs);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Gs)}class ei{constructor(t){if(!K().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Qs(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Ds(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if($s)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(o.signature=t.signature),null!=t.userDefinedMetadata&&(o.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(o.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const t=JSON.parse(o);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if($s){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(s),e}}ei.URL_SCHEME="localstorage://";const ni=t=>{return K().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ei.URL_SCHEME)?(e=t.slice(ei.URL_SCHEME.length),new ei(e)):null;var e};Ns.registerSaveRouter(ni),Ns.registerLoadRouter(ni);class ri{constructor(){h(K().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),h("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Vs+Gs,n=Gs+Ks;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);o.startsWith(e)&&o.endsWith(n)&&(t[ti(o)]=JSON.parse(this.LS.getItem(o)))}return t}async removeModel(t){var e;const n=Qs(t=(e=t).startsWith(ei.URL_SCHEME)?e.slice(ei.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}const oi="://";class si{constructor(){this.managers={}}static getInstance(){return null==si.instance&&(si.instance=new si),si.instance}static registerManager(t,e){h(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(oi)&&(t=t.slice(0,t.indexOf(oi))),h(t.length>0,(()=>"scheme must not be an empty string."));const n=si.getInstance();h(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function ii(t){if(-1===t.indexOf(oi))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${si.getSchemes().join(",")}`);return{scheme:t.split(oi)[0],path:t.split(oi)[1]}}async function ai(t,e,n=!1){h(t!==e,(()=>`Old path and new path are the same: '${t}'`));const r=Ns.getLoadHandlers(t);h(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),h(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`));const o=r[0],s=Ns.getSaveHandlers(e);h(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),h(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`));const i=s[0],a=ii(t).scheme,l=ii(t).path,u=a===ii(t).scheme,c=await o.load();n&&u&&await si.getManager(a).removeModel(l);const d=await i.save(c);return n&&!u&&await si.getManager(a).removeModel(l),d.modelArtifactsInfo}async function li(){const t=si.getSchemes(),e={};for(const n of t){const t=await si.getManager(n).listModels();for(const r in t)e[n+oi+r]=t[r]}return e}async function ui(t){const e=ii(t);return si.getManager(e.scheme).removeModel(e.path)}async function hi(t,e){return ai(t,e,!1)}async function ci(t,e){return ai(t,e,!0)}class di{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(K().get("IS_BROWSER")){K().setPlatform("browser",new di);try{si.registerManager(ei.URL_SCHEME,new ri)}catch(t){}try{si.registerManager(qs.URL_SCHEME,new Hs)}catch(t){}}let fi;function pi(t,e="float32",n){return e=e||"float32",j(t),new Co(t,e,n)}K().get("IS_NODE")&&K().setPlatform("node",new class{constructor(){this.util=n(1323),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=K().global.fetch?K().global.fetch(t,e):(null==fi&&(fi=n(759)),fi(t,e))}now(){const t=Et.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const gi=bs({cast_:function(t,e){const n=ms(t,"x","cast");if(!x(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},o={dtype:e};return as.runKernel(Gt,r,o)}}),mi=bs({clone_:function(t){const e={x:ms(t,"x","clone","string_or_numeric")};return as.runKernel(Le,e)}});function yi(t,e=!1){console.log(t.toString(e))}function wi(t){return new Promise((t=>setTimeout(t))).then(t)}is(),zo={buffer:pi,cast:gi,clone:mi,print:yi};class bi{constructor(t){if(!K().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(bi.URL_SCHEME)&&(t=t.slice(bi.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer);const o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(s.download=this.modelTopologyFileName,s.href=o,await wi((()=>s.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await wi((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Ds(t)}}}}bi.URL_SCHEME="downloads://";class Ei{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise(((n,r)=>{const o=new FileReader;o.onload=o=>{const s=JSON.parse(o.target.result),i=s.modelTopology;if(null==i)return void r(new Error(`modelTopology field is missing from file ${t.name}`));0===e.length&&n({modelTopology:i});const a=s.weightsManifest;if(null==a)return void r(new Error(`weightManifest field is missing from file ${t.name}`));let l;try{l=this.checkManifestAndWeightFiles(a,e)}catch(t){return void r(t)}const u=[],h=[],c=[];a.forEach((t=>{t.paths.forEach((t=>{h.push(t),c.push(null)})),u.push(...t.weights)})),a.forEach((t=>{t.paths.forEach((t=>{const e=new FileReader;e.onload=e=>{const r=e.target.result,o=h.indexOf(t);if(c[o]=r,-1===c.indexOf(null)){const t={modelTopology:i,weightSpecs:u,weightData:Ms(c),format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy};null!=s.signature&&(t.signature=s.signature),null!=s.userDefinedMetadata&&(t.userDefinedMetadata=s.userDefinedMetadata),null!=s.modelInitializer&&(t.modelInitializer=s.modelInitializer),n(t)}},e.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])}))}))},o.onerror=e=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(t)}))}checkManifestAndWeightFiles(t,e){const n=[],r=e.map((t=>Bs(t.name))),o={};for(const s of t)s.paths.forEach((t=>{const s=Bs(t);if(-1!==n.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(n.push(s),-1===r.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);o[t]=e[r.indexOf(s)]}));if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return o}}function vi(t){return new Ei(t)}function ki(t,e,n,r){!function(t){h(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){h(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),h(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),h(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(t.map((s=>(s.then((s=>{const i=n+ ++o/t.length*(r-n);return e(i),s})),s))))}async function Si(t,e){null==e&&(e={});const n=null==e.fetchFunc?K().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),o=(null==e.onProgress?await Promise.all(r):await ki(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(o):await ki(o,e.onProgress,.5,1)}async function Ii(t,e="",n,r){return Ai((t=>Si(t,{requestInit:r})))(t,e,n)}function Ai(t){return async(e,n="",r)=>{const o=e.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],a=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const l="quantization"in t?t.quantization.dtype:t.dtype,u=Ss[l]*p(t.shape),h=()=>{o[e]=!0,null==s[e]&&(s[e]=[]),s[e].push({manifestEntry:t,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((e,n)=>{e===t.name&&(h(),i[n]=!0)})):h(),a.push(t.name),n+=u}))})),!i.every((t=>t))){const t=r.filter(((t,e)=>!i[e]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${a.join(", ")}.`)}const l=o.reduce(((t,e,n)=>(e&&t.push(n),t)),[]),u=[];l.forEach((t=>{e[t].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)}))}));const h=await t(u),c={};let d=0;return l.forEach((t=>{const n=e[t].paths.length;let r=0;for(let t=0;t<n;t++)r+=h[d+t].byteLength;const o=new ArrayBuffer(r),i=new Uint8Array(o);let a=0;for(let t=0;t<n;t++){const e=new Uint8Array(h[d+t]);i.set(e,a),a+=e.byteLength}s[t].forEach((t=>{const e=As(o.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const t in e)c[t]=e[t]})),d+=n})),c}}Ns.registerSaveRouter((t=>K().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(bi.URL_SCHEME)?function(t="model"){return new bi(t)}(t.slice(bi.URL_SCHEME.length)):null));class xi{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(h("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=K().platform.fetch,h(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&h(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:Ds(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest,o=e.generatedBy,s=e.convertedBy,i=e.format,a=e.signature,l=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,h;if(null!=r){const t=await this.loadWeights(r);[u,h]=t}const c={modelTopology:n,weightSpecs:u,weightData:h,generatedBy:o,convertedBy:s,format:i};null!=a&&(c.signature=a),null!=l&&(c.userDefinedMetadata=l);const d=e.modelInitializer;return d&&(c.modelInitializer=d),c}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),o=this.weightPathPrefix||n,s=[];for(const e of t)s.push(...e.weights);const i=[],a=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?a.push(this.weightUrlConverter(t)):i.push(o+t+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),[s,Ms(await Si(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function $i(t){return null!=t.match(xi.URL_SCHEME_REGEX)}xi.URL_SCHEME_REGEX=/^https?:\/\//;const Ti=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>$i(t))):$i(t),n)return Mi(t,e)}return null};function Mi(t,e){return new xi(t,e)}function Bi(t,e){return Mi(t,e)}function Di(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(0===p(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const o=e.shape,s=o[o.length-1];let i=1;for(let t=0;t<o.length-1;++t)i*=o[t];const a=t.shape,l=o.slice();l.pop();let u=1;for(let t=s;t<n;++t)u*=a[t],l.push(a[t]);const h=[...O(t.shape).map((t=>t/u)),1].slice(0,s);return[l,i,u,h]}Ns.registerSaveRouter(Ti),Ns.registerLoadRouter(Ti);var Fi=Object.freeze({__proto__:null,prepareAndValidate:Di});function Ni(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(s+` update.rank < ${o}. `);if(t.length<r+(n.rank-o))throw new Error(s+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+t.length-r)throw new Error(s+" update.rank != "+(o+t.length-r));for(let t=0;t<o;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-o;++e)if(n.shape[e+o]!==t[e+r])throw new Error(s+` updates.shape[${e+o}] (${n.shape[e+o]}) != shape[${e+o}] (${t[e+o]})`)}function Ri(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}Ni(n,e,t)}function _i(t,e,n){const r=e.shape.length,o=r>1?e.shape[r-1]:1,s=n.length;let i=1;for(let t=o;t<s;++t)i*=n[t];const a=o<1?1:o;return{sliceRank:o,numUpdates:p(e.shape)/a,sliceSize:i,strides:[...O(n.slice(0,o)),1],outputSize:p(n)}}var Li=Object.freeze({__proto__:null,validateUpdateShape:Ni,validateInput:Ri,calculateShapes:_i});function Oi(t,e,n){const r=t.shape.length;h(r===e.length,(()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`)),h(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let o=0;o<r;++o)h(e[o]+n[o]<=t.shape[o],(()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${e[o]+n[o]}) would overflow input.shape[${o}] (${t.shape[o]})`))}function Pi(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function Ci(t,e,n){const r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function Ui(t,e,n,r){const o=[...t];for(let t=o.length;t<r.length;t++)o.push(1);for(let t=0;t<n;t++)0===t?o[e]=1:(o.splice(e,0,1),o.pop());return o}function zi(t,e,n){return n<=t?n:n-(e-1)}function ji(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function qi(t,e,n,r,o,s,i,a,l){const u=t.length;let h=new Array(u),c=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;h=Wi(i,l,u,r,t),c=Hi(a,l,u,o,t),d=Ui(s,l,u,t)}else for(let e=0;e<u;e++)h[e]=Vi(i,r,s,t,e,l),c[e]=Ki(a,o,s,t,e,l),d[e]=Gi(s,e,l);return{begin:h,end:c,strides:d}}function Wi(t,e,n,r,o){const s=[...o],i=ji(n,e);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const i=zi(e,n,o);let a=r[i];t&1<<i&&(a=0),s[o]=a}return s}function Hi(t,e,n,r,o){const s=[...o],i=ji(n,e);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const i=zi(e,n,o);let a=r[i];t&1<<i&&(a=Number.MAX_SAFE_INTEGER),s[o]=a}for(let t=0;t<s.length;t++){const e=o[t];s[t]<0&&(s[t]+=e),s[t]=a(0,s[t],o[t])}return s}function Gi(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Vi(t,e,n,r,o,s){let i=e[o];const l=n[o]||1;(t&1<<o||s&1<<o||null==i)&&(i=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[o];return i<0&&(i+=u),i=a(0,i,u-1),i}function Ki(t,e,n,r,o,s){let i=e[o];const l=n[o]||1;(t&1<<o||s&1<<o||null==i)&&(i=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[o];return i<0&&(i+=u),i=l>0?a(0,i,u):a(-1,i,u-1),i}function Ji(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function Zi(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Xi(t,e,n){let r;const o=t.shape.length;let s;return r="number"==typeof e?[e,...new Array(o-1).fill(0)]:e.length<o?e.concat(new Array(o-e.length).fill(0)):e.slice(),r.forEach((t=>{h(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(h(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,s]}function Yi(t,e,n,r,o,s,i,a,l){let u=e.slice(),h=n.slice(),c=r;null==r&&(c=new Array(u.length));const d=Pi(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const f=t.length-u.length,p=Pi(a),g=t.slice();p.forEach((t=>{u[t]=0,h[t]=1,g.splice(t,0,1)}));const{begin:m,end:y,strides:w}=qi(g,d,f,u,h,c,o,s,i);u=m,h=y,c=w;const b=Pi(l);b.forEach((t=>{h[t]=u[t]+1,c[t]=1}));const E=Ci(u,h,c),v=E.filter(((t,e)=>-1===b.indexOf(e)));return{nonStrided:c.every((t=>1===t)),$begin:u,$end:h,$strides:c,size:E,newShape:g,outShape:v}}var Qi=Object.freeze({__proto__:null,assertParamsValid:Oi,maskToAxes:Pi,computeOutShape:Ci,stridesWithElidedDims:Ui,getNormalizedAxes:qi,startIndicesWithElidedDims:Wi,stopIndicesWithElidedDims:Hi,stridesForAxis:Gi,startForAxis:Vi,stopForAxis:Ki,isSliceContinous:Ji,computeFlatOffset:Zi,parseSliceParams:Xi,sliceInfo:Yi});function ta(){K().set("PROD",!0)}function ea(){K().set("DEBUG",!0)}function na(){K().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ra(t){K().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function oa(){as.disposeVariables()}function sa(){return as}function ia(){return as.memory()}function aa(t){return as.profile(t)}function la(t,e){return as.tidy(t,e)}function ua(t){ts(t).forEach((t=>t.dispose()))}function ha(t){return as.keep(t)}function ca(t){return as.time(t)}function da(t){return as.setBackend(t)}function fa(){return as.ready()}function pa(){return as.backendName}function ga(t){as.removeBackend(t)}function ma(t){return as.findBackend(t)}function ya(t){return as.findBackendFactory(t)}function wa(t,e,n=1){return as.registerBackend(t,e,n)}function ba(){return as.backend}function Ea(t,e){K().setPlatform(t,e)}const va=bs({mul_:function(t,e){let n=ms(t,"a","mul"),r=ms(e,"b","mul");[n,r]=Yo(n,r);const o={a:n,b:r};return as.runKernel(pn,o)}});function ka(t,e,n,r,o="NHWC",s){return Aa(t,[...e,t[3]],n,s,r,null,null,Ra(o))}function Sa(t,e,n,r,o,s,i="channelsLast"){const[a,l]=Ta(e);let u;if("channelsLast"===i)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,t[1],t[1]]}return Aa(t,u,n,r,o,s,!1,i)}function Ia(t,e,n,r,o,s,i="NDHWC"){const[a,l,u]=Ma(e);let h,c;if("NDHWC"===i)c="channelsLast",h=[a,l,u,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);c="channelsFirst",h=[a,l,u,t[1],t[1]]}return xa(t,h,n,r,o,!1,c,s)}function Aa(t,e,n,r,o,s,i=!1,a="channelsLast"){let[l,u,h,c]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,h,c]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,c,u,h]=t}const[d,f,,p]=e,[g,m]=Ta(n),[y,w]=Ta(r),b=Ba(d,y),E=Ba(f,w),{padInfo:v,outHeight:k,outWidth:S}=function(t,e,n,r,o,s,i,a,l){let u,h,c;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const o=function(t,e,n,r,o){null==r&&(r=$a(t,e,n));const s=t[1];return[Da((t[0]-e+2*r)/n+1,o),Da((s-e+2*r)/n+1,o)]}([e,n],s,r,t,a);h=o[0],c=o[1]}else if("same"===t){h=Math.ceil(e/r),c=Math.ceil(n/o);const t=Math.max(0,(h-1)*r+s-e),a=Math.max(0,(c-1)*o+i-n),l=Math.floor(t/2),d=t-l,f=Math.floor(a/2);u={top:l,bottom:d,left:f,right:a-f,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-s+1)/r),c=Math.ceil((n-i+1)/o);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],f="channelsLast"===l?t[1][1]:t[2][1],p="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:f,left:p,right:g,type:0===d&&0===f&&0===p&&0===g?"VALID":"EXPLICIT"},h=Da((e-s+d+f)/r+1,a),c=Da((n-i+p+g)/o+1,a)}}return{padInfo:u,outHeight:h,outWidth:c}}(o,u,h,g,m,b,E,s,a),I=i?p*c:p;let A;return"channelsFirst"===a?A=[l,I,k,S]:"channelsLast"===a&&(A=[l,k,S,I]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:h,inChannels:c,outHeight:k,outWidth:S,outChannels:I,padInfo:v,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:E,dilationHeight:y,dilationWidth:w,inShape:t,outShape:A,filterShape:e}}function xa(t,e,n,r,o,s=!1,i="channelsLast",a){let[l,u,h,c,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,h,c,d]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,h,c]=t}const[f,p,g,,m]=e,[y,w,b]=Ma(n),[E,v,k]=Ma(r),S=Ba(f,E),I=Ba(p,v),A=Ba(g,k),{padInfo:x,outDepth:$,outHeight:T,outWidth:M}=function(t,e,n,r,o,s,i,a,l,u,h){let c,d,f,p;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,o,s){null==o&&(o=$a(t,e,r));const i=t[1],a=t[2];return[Da((t[0]-e+2*o)/r+1,s),Da((i-e+2*o)/r+1,s),Da((a-e+2*o)/r+1,s),1]}([e,n,r,1],a,0,o,t,h);d=s[0],f=s[1],p=s[2]}else if("same"===t){d=Math.ceil(e/o),f=Math.ceil(n/s),p=Math.ceil(r/i);const t=(d-1)*o+a-e,h=(f-1)*s+l-n,g=(p-1)*i+u-r,m=Math.floor(t/2),y=t-m,w=Math.floor(h/2),b=h-w,E=Math.floor(g/2);c={top:w,bottom:b,left:E,right:g-E,front:m,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/o),f=Math.ceil((n-l+1)/s),p=Math.ceil((r-u+1)/i)}return{padInfo:c,outDepth:d,outHeight:f,outWidth:p}}(o,u,h,c,y,w,b,S,I,A,a),B=s?m*d:m;let D;return"channelsFirst"===i?D=[l,B,$,T,M]:"channelsLast"===i&&(D=[l,$,T,M,B]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:h,inWidth:c,inChannels:d,outDepth:$,outHeight:T,outWidth:M,outChannels:B,padInfo:x,strideDepth:y,strideHeight:w,strideWidth:b,filterDepth:f,filterHeight:p,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:A,dilationDepth:E,dilationHeight:v,dilationWidth:k,inShape:t,outShape:D,filterShape:e}}function $a(t,e,n,r=1){const o=Ba(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function Ta(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Ma(t){return"number"==typeof t?[t,t,t]:t}function Ba(t,e){return e<=1?t:t+(t-1)*(e-1)}function Da(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Fa(t){const[e,n,r]=Ta(t);return 1===e&&1===n&&1===r}function Na(t,e){return Fa(t)||Fa(e)}function Ra(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const _a=bs({reshape_:function(t,e){const n={x:ms(t,"x","reshape","string_or_numeric")},r={shape:e};return as.runKernel(Fn,n,r)}}),La=bs({sigmoid_:function(t){const e={x:ms(t,"x","sigmoid")};return as.runKernel(Kn,e)}});function Oa(t,e){const n=t.length,r=[];for(let o=0;o<n;o++){const s=n-1-o,i=t[s]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(s)}return r}function Pa(t,e){const n=[];for(let r=0;r<e.length;r++){const o=t[t.length-r-1],s=e.length-r-1,i=e[s];(null==o||1===o&&i>1)&&n.unshift(s)}return n}function Ca(t,e){const n=[],r=Math.max(t.length,e.length);for(let o=0;o<r;o++){let r=t[t.length-o-1];null==r&&(r=1);let s=e[e.length-o-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}const Ua=bs({elu_:function(t){const e={x:ms(t,"x","elu")};return as.runKernel(be,e)}}),za=bs({leakyRelu_:function(t,e=.2){const n={x:ms(t,"x","leakyRelu")},r={alpha:e};return as.runKernel(je,n,r)}}),ja=bs({sum_:function(t,e=null,n=!1){let r=ms(t,"x","sum");"bool"===r.dtype&&(r=gi(r,"int32"));const o={x:r},s={axis:e,keepDims:n};return as.runKernel(Xn,o,s)}});function qa(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Wa(t,e,n){const r=t.length+e.length,o=[];let s=0,i=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?o.push(t[s++]):o.push(e[i++]);return o}function Ha(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((e=>t[e]))]}function Ga(t,e){return Wa(t,e.map((t=>1)),e)}function Va(t,e,n){h(qa(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function Ka(t,e){if(qa(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Ja(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function Za(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function Xa(t,e="float32"){if("complex64"===e){const e=Xa(t,"float32"),n=Xa(t,"float32");return Es(e,n)}const n=z(p(t),e);return as.makeTensor(n,t,e)}const Ya=bs({prelu_:function(t,e){const n={x:ms(t,"x","prelu"),alpha:ms(e,"alpha","prelu")};return as.runKernel(xn,n)}}),Qa=bs({relu_:function(t){const e={x:ms(t,"x","relu")};return as.runKernel(Dn,e)}}),tl=bs({relu6_:function(t){const e={x:ms(t,"x","relu6")};return as.runKernel(On,e)}});function el(t,e){if((T(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&T(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vs(t,[],[],e)}const nl=bs({step_:function(t,e=0){const n={x:ms(t,"x","step")},r={alpha:e};return as.runKernel(Sr,n,r)}});function rl(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=pi(t,"int32"),o=pi([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const s=r.indexToLoc(n[e]),i=e*t.length;o.values.set(s,i)}return o.toTensor()}function ol(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return va(t,nl(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function sl(t,e){let n=e;const r=Pa(t.shape,e.shape);return r.length>0&&(n=ja(n,r)),_a(n,t.shape)}function il(t,e,n,r){if("linear"===e)return t;if("relu"===e)return Qa(t);if("elu"===e)return Ua(t);if("relu6"===e)return tl(t);if("prelu"===e)return Ya(t,n);if("leakyrelu"===e)return za(t,r);if("sigmoid"===e)return La(t);throw new Error(`Unknown fused activation ${e}.`)}const al=(t,e)=>!(t>0)||"linear"===e;function ll(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,o=t.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);const a=n(e,t[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}(t,e,n||ul)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function ul(t,e){return t>e?1:t<e?-1:0}function hl(t,e,n,r,o){return fl(t,e,n,r,o,0)}function cl(t,e,n,r,o,s){return fl(t,e,n,r,o,0,!1,s,!0)}function dl(t,e,n,r,o,s){return fl(t,e,n,r,o,s,!0)}function fl(t,e,n,r,o,s,i=!1,a=!1,l=!1){const u=[];for(let t=0;t<e.length;t++)e[t]>o&&u.push({score:e[t],boxIndex:t,suppressBeginIndex:0});u.sort(ml);const h=s>0?-.5/s:0,c=[],d=[];for(;c.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=e;if(n<o)break;let a=!1;for(let n=c.length-1;n>=i;--n){const i=pl(t,s,c[n]);if(i>=r){a=!0;break}if(e.score=e.score*gl(r,h,i),e.score<=o)break}e.suppressBeginIndex=c.length,a||(e.score===n?(c.push(s),d.push(e.score)):e.score>o&&ll(u,e,ml))}const f=c.length,p=n-f;a&&p>0&&(c.push(...new Array(p).fill(0)),d.push(...new Array(p).fill(0)));const g={selectedIndices:c};return i&&(g.selectedScores=d),l&&(g.validOutputs=f),g}function pl(t,e,n){const r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(o[0],o[2]),h=Math.min(o[1],o[3]),c=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),f=(a-s)*(l-i),p=(c-u)*(d-h);if(f<=0||p<=0)return 0;const g=Math.max(s,u),m=Math.max(i,h),y=Math.min(a,c),w=Math.min(l,d),b=Math.max(y-g,0)*Math.max(w-m,0);return b/(f+p-b)}function gl(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function ml(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function yl(t,e){const n=t[0].length;t.forEach(((t,e)=>{h(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),h(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=t[0];t.forEach(((t,o)=>{for(let s=0;s<n;s++)h(s===e||t[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${o}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`))}))}function wl(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}function bl(t){return t<=30?t:L(t,Math.floor(Math.sqrt(t)))}function El(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function vl(t,e,n,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)o=o.concat([t[r+1]/e[r],e[r]]);o=o.concat(t.slice(n+1))}return o}function kl(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],o=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?o.push(r):n.push(r);r.push(...n),r.push(0),r.push(...o)}return r}function Sl(t,e,n,r=!0){const o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?o.push(e[n-1]*t[n]):o.push(t[n]/e[n-1]):o.push(t[n]);return o}function Il(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Al(t,e,n){const r=t.slice(0,1);for(let o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}const xl=1.7580993408473768,$l=1.0507009873554805,Tl=.3275911,Ml=.254829592,Bl=-.284496736,Dl=1.421413741,Fl=-1.453152027,Nl=1.061405429;function Rl(...t){K().getBool("IS_TEST")||console.warn(...t)}function _l(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}const Ll=/->/g;function Ol(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(Ll,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,o]=t.split("->");h(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const s=r.split(","),i=s.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let t=0;t<o.length;++t){const e=o[t];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===a.indexOf(e)&&a.push(e)}for(let t=0;t<r.length;++t){const e=r[t];-1===a.indexOf(e)&&","!==e&&a.push(e)}const l=new Array(s.length);for(let t=0;t<i;++t){if(new Set(s[t].split("")).size!==s[t].length)throw new Error(`Found duplicate axes in input component ${s[t]}. Support for duplicate axes in input is not implemented yet.`);l[t]=[];for(let e=0;e<s[t].length;++e)l[t].push(a.indexOf(s[t][e]))}const u=a.length,c=[];for(let t=o.length;t<u;++t)c.push(t);return{allDims:a,summedDims:c,idDims:l}}function Pl(t,e){let n=new Array(t);n.fill(-1);for(let t=0;t<e.length;++t)n[e[t]]=t;const r=[];for(let e=0;e<t;++e)-1===n[e]&&r.push(e);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function Cl(t,e,n){const r=new Array(t);for(let t=0;t<n.length;++t){const o=n[t].shape;for(let n=0;n<e[t].length;++n)void 0===r[e[t][n]]?r[e[t][n]]=o[n]:h(r[e[t][n]]===o[n],(()=>`Expected dimension ${r[e[t][n]]} at axis ${n} of input shaped ${JSON.stringify(o)}, but got dimension ${o[n]}`))}}function Ul(t,e){const n=t,r=[];let o=0;0===t.length&&n.push(-1),o=t.length+1;for(let t=0;t<o;++t)r.push([]);const s=[];for(let t=0;t<n.length;++t){const o=jl(e,n[t]);for(const e of o)-1===s.indexOf(e)&&(r[t].push(e),s.push(e))}return{path:n,steps:r}}function zl(t){return t.every(((t,e)=>t===e))}function jl(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function ql(t,e,n=0){let r=[];if("number"==typeof e)h(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{h(e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0)<=1,(()=>"There should be only one negative value in split array."));const o=e.indexOf(-1);if(-1!==o){const r=e.reduce(((t,e)=>e>0?t+e:t));e[o]=t.shape[n]-r}h(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function Wl(t,e){let n,r=!1;for(t<=30?(n=t,r=!0):n=L(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=L(t,n+1);return n}function Hl(t,e,n){const r=[],o=t.length;for(let s=0;s<o;s++)s!==e?r.push(t[s]):r.push(n);return r}function Gl(t,e,n,r){const o=e.shape.length,s=t.shape.length;if(0!==r&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const i=t.shape[n],a=[];let l=1,u=1,h=1;for(let e=0;e<r;++e)a.push(t.shape[e]),l*=t.shape[e];for(let e=r;e<n;e++)a.push(t.shape[e]),u*=t.shape[e];for(let t=r;t<o;t++)a.push(e.shape[t]);for(let e=n+1;e<s;e++)a.push(t.shape[e]),h*=t.shape[e];return{batchSize:l,sliceSize:h,outerSize:u,dimSize:i,outputShape:a}}var Vl=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:Wl,computeOutShape:Hl,collectGatherOpShapeInfo:Gl});function Kl(t){try{return t.map((t=>Mo(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Jl(t){return t.map((t=>To(t)))}var Zl=Object.freeze({__proto__:null,slice_util:Qi,segment_util:Vl,fromUint8ToStringArray:Kl,fromStringArrayToUint8:Jl,upcastType:Zo,axesAreInnerMostDims:qa,combineLocations:Wa,computeOutAndReduceShapes:Ha,expandShapeToKeepDim:Ga,assertAxesAreInnerMostDims:Va,getAxesPermutation:Ka,getUndoAxesPermutation:Ja,getInnerMostAxes:Za,getBroadcastDims:Oa,getReductionAxes:Pa,assertAndGetBroadcastShape:Ca,assertParamsConsistent:yl,computeOutShape:wl,computeDilation2DInfo:ka,computePool2DInfo:Sa,computePool3DInfo:Ia,computeConv2DInfo:Aa,computeConv3DInfo:xa,computeDefaultPad:$a,tupleValuesAreOne:Fa,eitherStridesOrDilationsAreOne:Na,convertConv2DDataFormat:Ra,getFusedDyActivation:ol,getFusedBiasGradient:sl,applyActivation:il,shouldFuse:al,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:bl,getImageCenter:El,getReshaped:vl,getPermuted:kl,getReshapedPermuted:Sl,getSliceBeginCoords:Il,getSliceSize:Al,prepareAndValidate:Di,validateUpdateShape:Ni,validateInput:Ri,calculateShapes:_i,SELU_SCALEALPHA:xl,SELU_SCALE:$l,ERF_P:Tl,ERF_A1:Ml,ERF_A2:Bl,ERF_A3:Dl,ERF_A4:Fl,ERF_A5:Nl,warn:Rl,log:function(...t){K().getBool("IS_TEST")||console.log(...t)},mergeRealAndImagArrays:_l,splitRealAndImagArrays:function(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}},complexWithEvenIndex:function(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}},complexWithOddIndex:function(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}},getComplexWithIndex:function(t,e){return{real:t[2*e],imag:t[2*e+1]}},assignToTypedArray:function(t,e,n,r){t[2*r]=e,t[2*r+1]=n},exponents:function(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const s=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:n,imag:r}},exponent:function(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}},decodeEinsumEquation:Ol,getEinsumPermutation:Pl,checkEinsumDimSizes:Cl,getEinsumComputePath:Ul,isIdentityPermutation:zl,prepareSplitSize:ql})}}]);