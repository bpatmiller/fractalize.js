/*! For license information please see lib-gammacv.05b051588e23a0ff673f.js.LICENSE.txt */
(self.webpackChunkfractalize=self.webpackChunkfractalize||[]).push([[962],{6379:(t,e,a)=>{"use strict";a.d(e,{z_:()=>w,es:()=>O,Ig:()=>M,He:()=>$}),a(3807);class i{static GlobalCountIncrease(){return i.GlobalNodesCount+=1,i.GlobalNodesCount}constructor(t){this.id=i.GlobalCountIncrease(),this.name=`${t}:${this.id}`}}i.GlobalNodesCount=0;class s{constructor(t,e,a,i){this.gl=t,this.name=a,this.dtype=i,this.location=t.getUniformLocation(e,this.name)}set(t){const e=this.gl;switch(this.dtype){case"int":e.uniform1i(this.location,t);break;case"float":e.uniform1f(this.location,t);break;case"vec2":e.uniform2fv(this.location,t);break;case"vec3":e.uniform3fv(this.location,t);break;case"vec4":e.uniform4fv(this.location,t);break;case"mat3":e.uniformMatrix3fv(this.location,!1,t);break;case"mat4":e.uniformMatrix4fv(this.location,!1,t);break;default:return!1}return!0}}class n{constructor(t,e,a,i){this.program=e,this.gl=t,this.name=a,this.dtype=i,this.location=t.getAttribLocation(this.program,this.name),this.ctx=t.createBuffer(),this.empty=new ArrayBuffer(1),"float"===i||"int"===i?this.size=1:(this.size=parseInt(/\d/g.exec(i)[0],10),t.enableVertexAttribArray(this.location))}set(t){const e=this.gl;this.bind(this.ctx),"int"===this.dtype?e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),e.STATIC_DRAW):e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW)}bind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.ctx):(t.bindBuffer(t.ARRAY_BUFFER,this.ctx),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}unbind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null):(t.bindBuffer(t.ARRAY_BUFFER,null),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}disable(){this.gl.disableVertexAttribArray(this.ctx)}enable(){this.gl.enableVertexAttribArray(this.ctx)}delete(){this.gl.deleteBuffer(this.ctx),this.program=null,this.gl=null,this.ctx=null}}const r="Error: An error occurred compiling the shaders: ";function o(t){const e=/\d+\|(\s+)/.exec(t);return" ".repeat(e?e[1].length:2)}function h(t){let e=t.split("\n");const a=(e.length+1).toString().length;return e=e.map(((t,e)=>`${(e+1).toString().padStart(a)}|  ${t}`)),e}const l=["pickCurrentValue","pickValue","float"],d=(t,e)=>{if(!t)throw new Error(e)},u=t=>{((t,e)=>{d(t,`GammaCV: DOMFeature not supported, "${e}" is not supported in current environment`)})(document&&document.createElement,t)},c=t=>Array.isArray(t)&&t.length>0&&!t.some((t=>t%1!=0)),f=t=>t instanceof F,p=t=>t instanceof I,g=t=>t instanceof O,y=t=>"function"==typeof HTMLVideoElement&&t instanceof HTMLVideoElement,E=t=>"function"==typeof HTMLCanvasElement?t instanceof HTMLCanvasElement:"getContext"in t,T=t=>/^[A-Za-z](\w+)?$/.test(t);function m(){try{return u("canvas"),document.createElement("canvas")}catch(t){return d("function"==typeof OffscreenCanvas,"OffscreenCanvas"),new OffscreenCanvas(1,1)}}Error;const x={},b={SUPPORTS_FLOAT_TEXTURES:function(){let t,e=!1;try{const a=m().getContext("webgl");if(!a)return!1;if(!a.getExtension("OES_texture_float"))return!1;const i=a.createFramebuffer(),s=a.createTexture();x.MAX_TEXTURE_SIZE=a.getParameter(a.MAX_TEXTURE_SIZE),a.bindTexture(a.TEXTURE_2D,s),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,1,1,0,a.RGBA,a.FLOAT,null),a.bindFramebuffer(a.FRAMEBUFFER,i),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,s,0),e=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE,a.readPixels(0,0,1,1,a.RGBA,a.FLOAT,new Float32Array(4)),t=a.getError()===a.NO_ERROR}catch(e){t=!1}return e&&t}(),DEBUG:!1,MAX_TEXTURE_SIZE:x.MAX_TEXTURE_SIZE},A=Object.assign({},b);function R(t){let e="\nvoid main(void) {\n  vec2 coords = gl_FragCoord.xy - 0.5;\n  vec4 result = operation(coords.y, coords.x);\n\n  gl_FragColor = result;\n}\n  ";return A.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.dtype||(e="\n    void main(void) {\n      vec2 coords = gl_FragCoord.xy;\n\n      highp float ox = floor(coords.x / 4.0);\n      float dx = floor(coords.x - ox * 4.0 + 0.5);\n    \n      vec4 result = operation(coords.y - 0.5, floor((coords.x - 0.5) / 4.0));\n\n      float value;\n\n      if (dx == 1.0) {\n        value = result.r;\n      } else if (dx == 2.0) {\n        value = result.g;\n      } else if (dx == 3.0) {\n        value = result.b;\n      } else if (dx == 4.0) {\n        value = result.a;\n      }\n    \n      gl_FragColor = encode_float(value);\n    }\n    "),e}var S=Object.freeze({main:R,pickValue:function(t){const e=Object.keys(t.input),a=[];for(let i=0;i<e.length;i+=1){const s=e[i];if(!t.input[s].shape)continue;const n=[...t.input[s].shape],r=n[1].toFixed(1),o=n[0].toFixed(1),h=(4*n[1]).toFixed(1);let l=(t,e,a)=>`${t} ${e}_${s}(float y, float x) {\n\treturn texture2D(${s}, vec2((x + 0.5) / ${r}, (y + 0.5) / ${o}))${a};\n}`;A.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.input[s].dtype||(l=(t,e,a)=>`\n        ${t} ${e}_${s}(float y, float x) {\n          float r = decode_float(texture2D(${s}, vec2((x * 4.0 + 0.5) / ${h}, y / ${o})));\n          float g = decode_float(texture2D(${s}, vec2((x * 4.0 + 1.5) / ${h}, y / ${o})));\n          float b = decode_float(texture2D(${s}, vec2((x * 4.0 + 2.5) / ${h}, y / ${o})));\n          float a = decode_float(texture2D(${s}, vec2((x * 4.0 + 3.5) / ${h}, y / ${o})));\n\n          return vec4(r, g, b, a)${a};\n        }\n      `),a.push(l("vec4","pickValue","")),a.push(l("float","pickScalarValue",".x"))}return a.join("\n")},float:()=>"precision highp float;highp vec4 encode_float(highp float f){if(f==1./0.){return vec4(0.0,0.0,128.0,127.0)/255.0;}highp vec4 rgba;highp float e=5.0;highp float F=abs(f);highp float sign=step(0.0,-f);highp float exponent=floor(log2(F));highp float mantissa=(exp2(-exponent)*F);exponent=floor(log2(F)+127.0)+floor(log2(mantissa));rgba[0]=128.0*sign+floor(exponent*exp2(-1.0));rgba[1]=128.0*mod(exponent,2.0)+mod(floor(mantissa*64.0*2.0),128.0);rgba[2]=floor(mod(floor(mantissa*exp2(23.0-8.0)),exp2(8.0)));rgba[3]=floor(exp2(23.0)*mod(mantissa,exp2(-15.0)));return rgba.abgr/255.0;}float decode_float(highp vec4 rgba){rgba=rgba.abgr*255.0;highp float sign=1.0-step(128.0,rgba[0])*2.0;highp float exponent=2.0*mod(rgba[0],128.0)+step(128.0,rgba[1])-127.0;exponent=floor(exponent+0.5);highp float mantissa=mod(rgba[1],128.0)*32768.0*2.0+rgba[2]*256.0+rgba[3]+float(0x800000);highp float result=sign*mantissa*exp2(-23.0)*exp2(exponent);return result;}"});function _(t){return["bool","int","uint","float","double","vec2","vec3","vec4","mat2","mat3","mat4","sampler2D"].indexOf(t)>=0}function v(t){let e=typeof t;t=String(t);const a=/^(vec\d|mat\d)\([^)]+\)$/.exec(t);return a?e=a[1]:/^\d+$/.exec(t)?e="int":/^\d+\.(\d+)?$/.exec(t)?e="float":"boolean"===e&&(e="bool"),e}class F extends i{constructor(t){d(void 0!==t,"Operation: Operation should have a name"),super(t),this.dtype=null,this.input={},this.uniform={},this.constant={},this.chunks=[],this.inputKeys=[],this.isInitialized=!1,this.lastCtx=Math.random(),this.cache=!0}run(t,e,a){d(this.isInitialized,"Operation: Unable to run uninitialized operation.");const i=this.gl,s=t.texture[this.name];if(e===this.lastCtx&&this.cache&&!a)return s.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),!1;this.lastCtx=e,i.useProgram(this.program);for(let e=0;e<this.inputKeys.length;e+=1){const a=this.inputKeys[e],i=this.input[a],s=i.name,n=t.texture[s];n.bind(this.program,a,e),g(i)&&n.set(i),p(i)&&n.set(i.media)}return s.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),A.SUPPORTS_FLOAT_TEXTURES?i.viewport(0,0,this.shape[1],this.shape[0]):i.viewport(0,0,("float32"===this.dtype?4:1)*this.shape[1],this.shape[0]),i.clearColor(0,0,0,1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.drawElements(i.TRIANGLES,6,i.UNSIGNED_SHORT,0),!0}unbindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)}bindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer)}init(t){if(!this.isInitialized){if(this.gl=t,this.program=t.createProgram(),this.framebuffer=t.createFramebuffer(),this.isInitialized)return!1;this.constant.OUT_VIEW=`vec2(${this.shape[1]}, ${this.shape[0]})`,this.kernel=function(t){let e;if(a=t.kernel,/void main\(([^)]+)?\)([\s]+)?{/.exec(a))e=t.kernel;else{const a=function(t){const e=Object.assign({},t.uniform),a=Object.keys(t.input);let i="precision highp float;\n";for(let t=0;t<a.length;t+=1)e[a[t]]={dtype:"sampler2D"};const s=Object.keys(e);for(let t=0;t<s.length;t+=1){const a=s[t];if(!_(e[a].dtype))throw new Error(`KernelConstructor: Uniform ${a} has invalid type "${e[a].dtype}"`);i+=`uniform ${e[a].dtype} ${a};\n`}i+="varying vec2 texCoords;\n";const n=Object.keys(t.constant);for(let e=0;e<n.length;e+=1){const a=n[e];let s=t.constant[a];"number"==typeof s&&s%1==0&&(s=s.toFixed(1));const r=v(s);if(!_(r))throw new Error(`KernelConstructor: Constant ${a}, has invalid type "${r}"`);i+=`#define ${a} ${s}\n`}return i}(t),i=function(t){const e=[];return A.SUPPORTS_FLOAT_TEXTURES||e.push("float"),e.concat(t.chunks.filter(((t,e,a)=>a.indexOf(t)===e))).map((e=>{const a=` Chunk ${e} `,i=35-a.length,s=`${"-".repeat(Math.floor(i/2))}${a}${"-".repeat(Math.ceil(i/2))}`;if("function"==typeof S[e])return`/*${s}*/\n${S[e](t)}\n/*${"-".repeat(35)}*/`;throw new TypeError(`KernelConstructor: Chunk "${e}" is not a function`)})).join("\n")}(t),s=R(t);e=[a,i,t.kernel,s].join("\n\n")}var a;return A.DEBUG&&(console.groupCollapsed(t.name),console.log(h(e).join("\n")),console.groupEnd()),e}(this);try{this.vertexShader=this.getShader("vertex","precision highp float;attribute vec3 aVertexPosition;attribute vec2 aTextureCoords;varying vec2 texCoords;void main(void){texCoords=aTextureCoords;gl_Position=vec4(aVertexPosition,1.0);}"),t.attachShader(this.program,this.vertexShader),this.fragmentShader=this.getShader("fragment",this.kernel),t.attachShader(this.program,this.fragmentShader),t.linkProgram(this.program),t.useProgram(this.program)}catch(t){throw function(t,e,a){try{const i=function(t,e,a=!0){const i=h(t),s=(i.length+1).toString().length;let n=e.toString();const l=[],d=[];n.startsWith(r)&&(n=n.substr(r.length));const u=n.split("\n"),c=function(t){let e=0,a=0;for(let i=0;i<t.length;i+=1)/ERROR/.exec(t[i])&&(e+=1),/WARNING/.exec(t[i])&&(a+=1);return{errCount:e,warnCount:a}}(u);let f=0;for(let t=0;t<u.length;t+=1){const e=u[t],n=/0:(\d+)/.exec(e);if(n){const t=+n[1]+f,r=`${" ".repeat(s)}|${o(i[t-1])}`;l.push(`${e}\n${i[t-2]}\n${i[t-1]}\n${r}^\n${i[t]}`);const h=a?"%c":"";i.splice(t,0,`${h}${r}^--${e}${h}`),a&&(d.push("color: red;"),d.push("color: inherit;")),f+=1}}return{fullText:i.join("\n"),firstError:l[0],errorsStats:c,fullTextStyle:d}}(t,a),s=i.errorsStats;console.group(`Error: An error occurred compiling the shader ${e}: ${s.errCount} ERRORS, ${s.warnCount} WARNINGS`),console.log(i.firstError),console.groupCollapsed("Show more"),console.log(i.fullText,...i.fullTextStyle),console.groupEnd(),console.groupEnd()}catch(t){console.warn("Unable to process GLSG compiling error.")}}(this.kernel,this.name,t),new Error(`Operation: Error during shader compilation.\n${t.message}`)}this.attributes={aVertexPosition:new n(this.gl,this.program,"aVertexPosition","vec3"),aTextureCoords:new n(this.gl,this.program,"aTextureCoords","vec2"),aIndices:new n(this.gl,this.program,"aIndices","int")},this.attributes.aVertexPosition.set([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),this.attributes.aTextureCoords.set([1,1,0,1,0,0,1,0]),this.attributes.aIndices.set([0,1,2,0,2,3]);const e=Object.keys(this.uniform);for(let t=0;t<e.length;t+=1){const a=this.uniform[e[t]];this.uniform[e[t]]=new s(this.gl,this.program,a.name,a.dtype),a.defaultValue&&this.uniform[e[t]].set(a.defaultValue)}this.isInitialized=!0}return!0}getShader(t,e){const a=this.gl;let i=null;if(i="fragment"===t?a.createShader(a.FRAGMENT_SHADER):a.createShader(a.VERTEX_SHADER),a.shaderSource(i,e),a.compileShader(i),!a.getShaderParameter(i,a.COMPILE_STATUS))throw new Error(`Operation: An error occurred compiling the shaders.\n${a.getShaderInfoLog(i)}`);return i}traverse(t,e){const a=Object.keys(this.input);for(let i=0;i<a.length;i+=1){const s=a[i];f(this.input[s])?this.input[s].traverse(t,e):t(this.input[s],e)}t(this,e)}getDependencies(){const t=[],e=Object.keys(this.input);for(let a=0;a<e.length;a+=1){const i=e[a];if(f(this.input[i])){const e=this.input[i].getDependencies();for(let a=0;a<e.length;a+=1)-1===t.indexOf(e[a])&&t.push(e[a])}}return t.push(this.name),t}assignInput(t,e){this.input[t]=e,-1===this.inputKeys.indexOf(t)&&this.inputKeys.push(t)}cloneProp(t){const e=Object.keys(this[t]),a={};for(let i=0;i<e.length;i+=1){const s=e[i];a[s]=this[t][s]}return a}destroy(){this.program&&this.gl.deleteProgram(this.program),this.vertexShader&&this.gl.deleteShader(this.vertexShader),this.fragmentShader&&this.gl.deleteShader(this.fragmentShader),this.framebuffer&&this.gl.deleteFramebuffer(this.framebuffer)}clone(){const t=new F(this.name.split(":")[0]);return t.input=this.cloneProp("input"),t.uniform=this.cloneProp("uniform"),t.constant=this.cloneProp("constant"),t.dtype=this.dtype,t.kernel=this.kernel,t.chunks=this.chunks,t}}class U{constructor(t,e,a,i){if("float32"!==t&&"uint8"!==t)throw new Error(`GPUTexture: Invalid texture type, currently supported is: float32, uint8, but got ${t} `);this.unit=a,this.dtype=t,this.gl=e,this.ctx=e.createTexture(),this.shape=i,e.bindTexture(e.TEXTURE_2D,this.ctx),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.allocate()}allocate(){const t=this.gl;let e=this.shape[1],a=t.UNSIGNED_BYTE;"float32"===this.dtype&&(A.SUPPORTS_FLOAT_TEXTURES?a=t.FLOAT:e*=4),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,this.shape[0],0,t.RGBA,a,null)}set(t=null){const e=this.gl;if(y(t)||E(t))e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t);else{let a=t.shape[1],i=e.UNSIGNED_BYTE,s=t.data;"float32"===t.dtype&&(A.SUPPORTS_FLOAT_TEXTURES?i=e.FLOAT:(a*=4,s=t.uint8View)),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a,this.shape[0],0,e.RGBA,i,s)}}bind(t,e,a){const i=this.gl;if(e){const s=i.getUniformLocation(t,e);i.uniform1i(s,a)}i.activeTexture(i.TEXTURE0+a),i.bindTexture(i.TEXTURE_2D,this.ctx),this.unit=a}unbind(){const t=this.gl;t.activeTexture(t.TEXTURE0+this.unit),t.bindTexture(t.TEXTURE_2D,null)}delete(){const t=this.gl;t.deleteTexture(this.ctx),this.gl=null,this.program=null,this.ctx=null,t.bindTexture(t.TEXTURE_2D,null)}}class w{constructor(){this.canvas=m(),this.canvas.width=1,this.canvas.height=1,this.initWebGL(this.canvas),this.operation={},this.texture={},this.textureCount=0}initWebGL(t,e){this.canvas=t;const a=this.canvas.getContext("webgl",e);d(!!a,"Session: WebGL not supported.");const i=a.getExtension("OES_texture_float");d(!!i,"Session: Unable to find extension OES_texture_float"),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.gl=a}init(t){d(!!t,"Session: Unable to initialize undefined operation"),d(f(t)||g(t),"Session: Unable to initialize operation with invalid input type"),f(t)&&t.traverse(((t,e)=>{e.operation[t.name]=t}),this),(g(t)||p(t))&&(this.operation[t.name]=t),this.update()}update(){const t=this.gl,e=Object.keys(this.operation);for(let a=0;a<e.length;a+=1){const i=this.operation[e[a]];i instanceof F&&i.init(this.gl),this.texture[e[a]]||(this.texture[e[a]]=new U(i.dtype,this.gl,this.textureCount,i.shape),i instanceof F&&(t.bindFramebuffer(t.FRAMEBUFFER,i.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture[e[a]].ctx,0),t.bindFramebuffer(t.FRAMEBUFFER,null)),this.textureCount+=1)}}runOp(t,e,a=!1){const i=t.sequence;let s=!1;for(let n=0;n<i.length;n+=1){const r=i[n],o=this.operation[r],h=n===i.length-1;d(!!o,`Session: Unable to run uninitialized operation ${t.name}.`),E(a)&&h&&(this.canvas.width===o.shape[1]&&this.canvas.height===o.shape[0]||(this.canvas.width=o.shape[1],this.canvas.height=o.shape[0]),o.framebuffer=null),s=!!o.run(this,e,s),a&&h&&g(a)&&this.readToTensor(a),a&&h&&E(a)&&this.readToCanvas(a,o.shape)}}destroy(){const t=this.gl.getExtension("WEBGL_lose_context"),e=Object.keys(this.texture),a=Object.keys(this.operation);t&&t.loseContext();for(let t=0;t<e.length;t+=1)this.texture[e[t]].delete();for(let t=0;t<a.length;t+=1){const e=this.operation[a[t]];e instanceof F&&e.destroy()}this.canvas=null,this.operation={},this.texture={},this.gl=null,this.textureCount=0}readToTensor(t){const e=this.gl,a=t.shape[0];let i=t.shape[1],s=e.UNSIGNED_BYTE,n=t.data;"float32"===t.dtype&&(A.SUPPORTS_FLOAT_TEXTURES?s=e.FLOAT:(i*=4,n=t.uint8View)),e.readPixels(0,0,i,a,e.RGBA,s,n)}readToCanvas(t,e){const a=t.getContext("2d");t.width=e[1],t.height=e[0],a.drawImage(this.canvas,0,0,e[1],e[0],0,0,e[1],e[0])}}class C{constructor(t){this.op=new F(t),this.name=t,this.checkShape=t=>t[Object.keys(t)[0]],this.preCompile=()=>{},this.postCompile=()=>{},this.chunks=[]}GLSLKernel(t){return d("string"==typeof t,"RegisterOperation: The kernel should be a string but it is not."),this.op.kernel=t,this}LoadChunk(...t){for(const a of t)d((e=a,l.includes(e)),`RegisterOperation: There is no available GLSL chunk supported: ${a}`);var e;return this.op.chunks=this.op.chunks.concat(t),this}Input(t,e){return d(T(t)),this.op.input[t]={name:t,dtype:e},this}Output(t){return d(null===this.op.dtype,"RegisterOperation: The operation allows a single output."),this.op.dtype=t,this}Constant(t,e){return d(T(t)),this.op.constant[t]=e,this}SetShapeFn(t){return d("function"==typeof t,"RegisterOperation: SetShapeFn should receive function in first argument"),this.checkShape=t,this}PreCompile(t){return d("function"==typeof t,"RegisterOperation: PreCompile should receive function in first argument"),this.preCompile=t,this}PostCompile(t){return d("function"==typeof t,"RegisterOperation: PostCompile should receive function in first argument"),this.postCompile=t,this}Uniform(t,e,a){return d(T(t)),this.op.uniform[t]={name:t,dtype:e,defaultValue:a},this}Compile(t){const e=this.op.clone(),a={},i=Object.keys(t);this.preCompile(e);for(let s=0;s<i.length;s+=1){const n=i[s],r=t[n];d(!!r,`RegisterOperation:${e.name}.${n}:\n         Can't compile operation with undefined input.`),d(g(r)||p(r)||f(r),`RegisterOperation:${e.name}.${n}:\n         Can't compile operation with invalid input type.\n         You can only use Tensor or another Operation to be an input`),a[n]=t[n].shape,e.assignInput(n,t[n])}return e.shape=this.checkShape(a),e.sequence=e.getDependencies(),e}}function $(t,e=!1){let a=null;return f(t)&&(a=new O(e||t.dtype,t.shape)),g(t)&&(a=new O(e||t.dtype,t.shape)),p(t)&&(a=new O(e||t.dtype,t.shape)),a}class O extends i{constructor(t,e,a,i,s=0){super("Tensor"),this.dtype=t,this.shape=e||[a.length],d(c(this.shape),"Tensor: Shape is not valid"),i&&(d(c(i),"Tensor: Stride is not valid"),d(this.shape.length===i.length,"Tensor: Stride length should be equal to shape length")),d("number"==typeof s&&s%1==0,`Tensor: Offset should be integer, but got ${s}`),this.size=O.GetSize(this.shape),this.stride=i||this._defineStride(this.shape),this.offset=s,this._compileJITMethods(),void 0===a?(this.data=O.Malloc(t,this.size),this.empty=O.Malloc(t,this.size)):this.assign(a),A.SUPPORTS_FLOAT_TEXTURES||"float32"!==t||(this.uint8View=new Uint8Array(this.data.buffer))}_compileJITMethods(){const t=function(t){const e=new Array(t);for(let a=0;a<t;a+=1)e[a]=a;return e}(this.shape.length),e=t.map((t=>`i${t}`)).join(","),a=`${this.offset}+${t.map((t=>`${this.stride[t]}*i${t}`)).join("+")}`;this.get=new Function(`return function get(${e}) { return this.data[${a}]; }`)(),this.set=new Function(`return function get(${e}, v) { this.data[${a}] = v; }`)(),this.index=new Function(`return function get(${e}, v) { return ${a}; }`)()}_defineStride(t){const e=t.length,a=new Array(e);for(let t=e-1,i=1;t>=0;t-=1)a[t]=i,i*=this.shape[t];return a}assign(t){const e=O.DefineType(t),a=t.length;return d(e===this.dtype,`Tensor: Different dtypes assigned: \n   expected - ${this.dtype} \n   actual - ${e}`),d(a===this.size+this.offset,`Tensor: Different sizes assigned: \n   expected - ${this.size+this.offset} \n   actual - ${a}`),this.data=t,this}release(){return this.empty?this.data.set(this.empty):this.data=O.Malloc(this.dtype,this.size),this}relese(){return t="Tensor: relese",console.warn(`GammaCV Deprecation Warning: "${t}" is deprecated${e?`, ${e}`:""}. "${t}" will be removed in next major version.`),this.release(),this;var t,e}clone(){const t=new O(this.dtype,this.shape,void 0,this.stride,this.offset);return function(t,e){if(e.data.set)e.data.set(t.data);else for(let a=0;a<e.size;a+=1)e.data[a]=t.data[a]}(this,t),t}static IndexToCoord(t,e){const a=new Array(t.length);let i=e,s=t.reduce(((t,e)=>t*e));for(let e=0;e<=t.length-2;e+=1){s/=t[e];const n=~~(i/s);i%=s,a[e]=n}return a[a.length-1]=i%t[t.length-1],a}static CoordToIndex(t,e){let a=1,i=0;for(let s=t.length-1;s>=0;s-=1)i+=a*e[s],a*=t[s];return i}static Malloc(t,e){switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Tensor: Unexpected type: ${t}.`)}}static DefineType(t){const e=Object.prototype.toString.call(t);switch(e){case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Float32Array]":return"float32";case"[object Float64Array]":return"float64";case"[object Uint8ClampedArray]":return"uint8c";case"[object Array]":return"array";default:throw new Error(`Tensor: Unknown dtype: ${e}.`)}}static GetTypedArray(t,e){if(t===O.DefineType(e))return e;switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Unknown type: ${t}.`)}}static GetSize(t){return t.reduce(((t,e)=>t*e),1)}}class I extends i{constructor(t,e){super("MediaInput"),this.dtype="uint8",this.inputKeys=[],this.isInitialized=!1,this.lastCtx=Math.random(),this.cache=!0,this.assignMedia(t,e)}assignMedia(t,e){t&&d(y(t)||E(t),"MediaInput: Is only Video, Canvas element available as input"),e&&d(c(e),"MediaInput: Shape is invalid"),this.media=t,this.shape=e}}var M=(t,e=3)=>(d("uint8"===t.dtype,"Color Segmentation currently available for uint8 image input"),d(e>1,"Number of clusters should be greater than 1"),new C("ImageColorSegmentation").Input("tSrc","uint8").Input("tCentroids","uint8").Output("uint8").LoadChunk("pickValue").Constant("CLUSTERS",e).GLSLKernel("const float _step=1.0/CLUSTERS;vec4 operation(float y,float x){float minDistance=256.0;float label=0.0;vec3 value=pickValue_tSrc(y,x).rgb;for(int i=0;i<int(CLUSTERS);i+=1){vec3 curr=pickValue_tCentroids(float(i),0.0).rgb;float distance=sqrt(((value.r-curr.r)*(value.r-curr.r)));if(distance<minDistance){minDistance=distance;label=float(i)/CLUSTERS;}}return vec4(label,label,label,1.0);}").PreCompile((t=>{const a=~~(256/e);t.centroids=new O("uint8",[e,1,4]);for(let i=0;i<e;i+=1)t.centroids.set(i,0,0,i*a);t.assignInput("tCentroids",t.centroids)})).Compile({tSrc:t}));function D(t,e,a){return t-1e-7<=e&&e<=a+1e-7}class L{static Intersection(t,e){const a=t.x1,i=t.y1,s=t.x2,n=t.y2,r=e.x1,o=e.y1,h=e.x2,l=e.y2,d=((a*n-i*s)*(r-h)-(a-s)*(r*l-o*h))/((a-s)*(o-l)-(i-n)*(r-h)),u=((a*n-i*s)*(o-l)-(i-n)*(r*l-o*h))/((a-s)*(o-l)-(i-n)*(r-h));if(isNaN(d)||isNaN(u))return!1;if(a>=s){if(!D(s,d,a))return!1}else if(!D(a,d,s))return!1;if(i>=n){if(!D(n,u,i))return!1}else if(!D(i,u,n))return!1;if(r>=h){if(!D(h,d,r))return!1}else if(!D(r,d,h))return!1;if(o>=l){if(!D(l,u,o))return!1}else if(!D(o,u,l))return!1;return[d,u]}constructor(t,e,a,i,s,n){if(t instanceof ArrayBuffer)this.data=new Float32Array(t,e,8);else if(Array.isArray(t)){if(t.length<8)for(let e=t.length;e<=8;e+=1)t.push(0);this.data=new Float32Array(t)}else this.data=void 0!==t&&void 0!==e?new Float32Array([t,e,a,i,s,n,0,0]):new Float32Array(8)}set(t,e,a,i,s,n){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=i,this.data[4]=s,this.data[5]=n,this.data[6]=0,this.data[7]=0}fromParallelCoords(t,e,a,i,s,n){const r=a;let o,h;t>n?(o=s-n*e/(t-=n),h=(n/t-1)*a+o):(o=n*e/(t=n-t),h=(1-n/t)*a+o),this.set(0,o,r,h,t,e)}get length(){if(this.data[6])return this.data[6];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1],a=Math.sqrt(t**2+e**2);return this.data[6]=a,a}get angle(){if(this.data[7])return this.data[7];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1];let a=Math.atan(e/t)/Math.PI*180;return a<0&&(a=180+a),this.data[7]=a,a}get x1(){return this.data[0]}get y1(){return this.data[1]}get x2(){return this.data[2]}get y2(){return this.data[3]}get px(){return this.data[4]}get py(){return this.data[5]}set x1(t){this.data[0]=t}set y1(t){this.data[1]=t}set x2(t){this.data[2]=t}set y2(t){this.data[3]=t}set px(t){this.data[4]=t}set py(t){this.data[5]=t}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromArray(t){this.data.set(t)}toArray(){return Array.prototype.slice.call(this.data)}}function P(t,e){const a=t[2]-t[0],i=t[3]-t[1],s=e[2]-e[0],n=e[3]-e[1],r=a*s+i*n,o=(a*a+i*i)*(s*s+n*n);return Math.acos(r/Math.sqrt(o))}function k(t,e,a){const i=a;let s=0,n=0,r=0,o=0,h=0,l=0;return r=i.get(0,1)*e+i.get(0,2),o=i.get(1,1)*e+i.get(1,2),h=i.get(2,1)*e+i.get(2,2),r+=i.get(0,0)*t,o+=i.get(1,0)*t,h+=i.get(2,0)*t,l=1/h,s=r*l,n=o*l,[s,n]}L.BYTES_PER_ELEMENT=36;class B{static Distance(t,e){let a=0;for(let i=0;i<8;i+=2)a+=Math.sqrt((t.data[i]-e.data[i])**2+(t.data[i+1]-e.data[i+1])**2)**2;return a=Math.sqrt(a/8),a===1/0?0:a}static TriangleS(t,e,a,i,s,n){return Math.abs(t*(i-n)+a*(n-e)+s*(e-i))/2}constructor(...t){t[0]instanceof ArrayBuffer?this.data=new Float32Array(t[0],t[1],B.NUM_ELEMENTS):Array.isArray(t[0])?this.data=new Float32Array(t[0]):t[0]&&t.length===B.NUM_ELEMENTS?this.data=new Float32Array(t):this.data=new Float32Array(B.NUM_ELEMENTS)}isInRect(t,e){return!(B.TriangleS(t,e,this.ax,this.ay,this.bx,this.by)+B.TriangleS(t,e,this.cx,this.cy,this.bx,this.by)+B.TriangleS(this.cx,this.cy,t,e,this.dx,this.dy)+B.TriangleS(this.dx,this.dy,t,e,this.ax,this.ay)-this.area>0)}isNotEmpty(){return this.data[0]>0&&this.data[1]>0&&this.data[2]>0&&this.data[3]>0&&this.data[4]>0&&this.data[5]>0&&this.data[6]>0&&this.data[7]>0}clone(){return new B(this.toArray())}set(t,e,a,i,s,n,r,o){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=i,this.data[4]=s,this.data[5]=n,this.data[6]=r,this.data[7]=o}assign(t){return this.data.set(t.data),this}scale(t,e){return this.data[0]*=t,this.data[1]*=e,this.data[2]*=t,this.data[3]*=e,this.data[4]*=t,this.data[5]*=e,this.data[6]*=t,this.data[7]*=e,this}fromLines(t,e,a,i){const s=function(t,e){const a=[0,0];let i=null,s=null,n=null,r=null;a[0]+=t[0][0],a[0]+=t[1][0],a[0]+=t[2][0],a[0]+=t[3][0],a[1]+=t[0][1],a[1]+=t[1][1],a[1]+=t[2][1],a[1]+=t[3][1],a[0]/=4,a[1]/=4;for(let e=0;e<t.length;e+=1)t[e][0]>=a[0]&&t[e][1]>=a[1]&&(n=t[e]),t[e][0]<=a[0]&&t[e][1]<=a[1]&&(i=t[e]),t[e][0]>=a[0]&&t[e][1]<=a[1]&&(s=t[e]),t[e][0]<=a[0]&&t[e][1]>=a[1]&&(r=t[e]);return[i,s,n,r]}([L.Intersection(t,e),L.Intersection(e,a),L.Intersection(a,i),L.Intersection(i,t)]);return!!(s[0]&&s[1]&&s[2]&&s[3])&&(this.data[0]=s[0][0],this.data[1]=s[0][1],this.data[2]=s[1][0],this.data[3]=s[1][1],this.data[4]=s[2][0],this.data[5]=s[2][1],this.data[6]=s[3][0],this.data[7]=s[3][1],!0)}get ax(){return this.data[0]}get ay(){return this.data[1]}get bx(){return this.data[2]}get by(){return this.data[3]}get cx(){return this.data[4]}get cy(){return this.data[5]}get dx(){return this.data[6]}get dy(){return this.data[7]}set ax(t){this.data[0]=t}set ay(t){this.data[1]=t}set bx(t){this.data[2]=t}set by(t){this.data[3]=t}set cx(t){this.data[4]=t}set cy(t){this.data[5]=t}set dx(t){this.data[6]=t}set dy(t){this.data[7]=t}get distA(){return Math.sqrt((this.data[6]-this.data[0])**2+(this.data[7]-this.data[1])**2)}get distB(){return Math.sqrt((this.data[4]-this.data[2])**2+(this.data[5]-this.data[3])**2)}get distC(){return Math.sqrt((this.data[0]-this.data[2])**2+(this.data[1]-this.data[3])**2)}get distD(){return Math.sqrt((this.data[6]-this.data[4])**2+(this.data[7]-this.data[5])**2)}get distE(){return Math.sqrt((this.data[0]-this.data[4])**2+(this.data[1]-this.data[5])**2)}get distF(){return Math.sqrt((this.data[6]-this.data[2])**2+(this.data[7]-this.data[3])**2)}get angleA(){return P([this.data[6],this.data[7],this.data[0],this.data[1]],[this.data[0],this.data[1],this.data[2],this.data[3]])}get angleB(){return P([this.data[0],this.data[1],this.data[2],this.data[3]],[this.data[2],this.data[3],this.data[4],this.data[5]])}get angleC(){return P([this.data[2],this.data[3],this.data[4],this.data[5]],[this.data[4],this.data[5],this.data[6],this.data[7]])}get angleD(){return P([this.data[4],this.data[5],this.data[6],this.data[7]],[this.data[6],this.data[7],this.data[0],this.data[1]])}get area(){const t=this.distA,e=this.distB,a=this.distC,i=this.distD,s=(t+e+a+i)/2;return Math.sqrt((s-t)*(s-e)*(s-a)*(s-i))}get P(){return this.distA+this.distB+this.distC+this.distD}mul(t){return this.data[0]*=t,this.data[1]*=t,this.data[2]*=t,this.data[3]*=t,this.data[4]*=t,this.data[5]*=t,this.data[6]*=t,this.data[7]*=t,this}scaleAt(t){return this.data[0]-=t,this.data[1]-=t,this.data[2]-=t,this.data[3]+=t,this.data[4]+=t,this.data[5]+=t,this.data[6]+=t,this.data[7]-=t,this}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromDeep(t){return this.data[0]=t[0][0],this.data[1]=t[0][1],this.data[2]=t[1][0],this.data[3]=t[1][1],this.data[4]=t[2][0],this.data[5]=t[2][1],this.data[6]=t[3][0],this.data[7]=t[3][1],this}perspective(t){const e=k(this.data[0],this.data[1],t),a=k(this.data[2],this.data[3],t),i=k(this.data[4],this.data[5],t),s=k(this.data[6],this.data[7],t);return this.data[0]=e[0],this.data[1]=e[1],this.data[2]=a[0],this.data[3]=a[1],this.data[4]=i[0],this.data[5]=i[1],this.data[6]=s[0],this.data[7]=s[1],this}fromArray(t){return this.data.set(t),this}toArray(){return Array.prototype.slice.call(this.data)}isInside(t){return t.ax>this.ax&&t.ay>this.ay&&t.bx<this.bx&&t.by>this.by&&t.cx<this.cx&&t.cy<this.cy&&t.dx>this.dx&&t.dy<this.dy}toJSON(){return this.toArray()}}B.NUM_ELEMENTS=8,B.BYTES_PER_ELEMENT=B.NUM_ELEMENTS*Float32Array.BYTES_PER_ELEMENT}}]);