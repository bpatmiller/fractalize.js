/*! For license information please see lib-deeplab.dc9b30ce6f4c051b25ec.js.LICENSE.txt */
(self.webpackChunkfractalize=self.webpackChunkfractalize||[]).push([[459],{4768:(e,t,a)=>{"use strict";a.d(t,{z:()=>Ee});var n,s,r=a(8075),o=a(2069),p=(a(3006),Object.freeze({__proto__:null,AdadeltaOptimizer:o.A,AdagradOptimizer:o.a,AdamOptimizer:o.b,AdamaxOptimizer:o.c,MomentumOptimizer:o.M,Optimizer:o.O,RMSPropOptimizer:o.R,SGDOptimizer:o.S,Tensor:r.T,TensorBuffer:r.a,Variable:r.V,get Rank(){return r.R},sumOutType:r.s,upcastType:r.u,get Reduction(){return o.d},customGrad:o.e,grad:o.g,grads:o.f,valueAndGrad:o.v,valueAndGrads:o.h,variableGrads:o.i,Environment:r.E,env:r.e,get ENV(){return r.b},nextFrame:o.n,KernelBackend:r.K,DataStorage:r.D,abs:o.j,acos:o.k,acosh:o.l,add:o.m,addN:o.o,all:o.p,any:o.q,argMax:o.r,argMin:o.s,asin:o.t,asinh:o.u,atan:o.w,atan2:o.x,atanh:o.y,avgPool:o.z,avgPool3d:o.B,basicLSTMCell:o.C,batchToSpaceND:o.D,batchNorm:o.E,batchNorm2d:o.F,batchNorm3d:o.G,batchNorm4d:o.H,bincount:o.I,broadcastTo:o.J,buffer:r.c,cast:r.d,ceil:o.K,clipByValue:o.L,clone:r.f,complex:r.g,concat:o.N,concat1d:o.P,concat2d:o.Q,concat3d:o.T,concat4d:o.U,conv1d:o.V,conv2d:o.W,conv2dTranspose:o.X,conv3d:o.Y,conv3dTranspose:o.Z,cos:o._,cosh:o.$,cumsum:o.a0,denseBincount:o.a1,depthToSpace:o.a2,depthwiseConv2d:o.a3,diag:o.a4,dilation2d:o.a5,div:o.a6,divNoNan:o.a7,dot:o.a8,einsum:o.a9,elu:r.h,equal:o.aa,erf:o.ab,exp:o.ac,expandDims:o.ad,expm1:o.ae,eye:o.af,fill:o.ag,floor:o.ah,floorDiv:o.ai,gather:o.aj,greater:o.ak,greaterEqual:o.al,imag:o.am,isFinite:o.an,isInf:o.ao,isNaN:o.ap,leakyRelu:r.l,less:o.aq,lessEqual:o.ar,linspace:o.as,localResponseNormalization:o.at,log:o.au,log1p:o.av,logSigmoid:o.aw,logSoftmax:o.ax,logSumExp:o.ay,logicalAnd:o.az,logicalNot:o.aA,logicalOr:o.aB,logicalXor:o.aC,matMul:o.aD,max:o.aE,maxPool:o.aF,maxPool3d:o.aG,maxPoolWithArgmax:o.aH,maximum:o.aI,mean:o.aJ,meshgrid:o.aK,min:o.aL,minimum:o.aM,mirrorPad:o.aN,mod:o.aO,moments:o.aP,mul:r.m,multiRNNCell:o.aQ,multinomial:o.aR,neg:o.aS,notEqual:o.aT,oneHot:o.aU,ones:o.aV,onesLike:o.aW,outerProduct:o.aX,pad:o.aY,pad1d:o.aZ,pad2d:o.a_,pad3d:o.a$,pad4d:o.b0,pool:o.b1,pow:o.b2,prelu:r.p,print:r.i,prod:o.b3,rand:o.b4,randomGamma:o.b5,randomNormal:o.b6,randomUniform:o.b7,range:o.b8,real:o.b9,reciprocal:o.ba,relu:r.r,relu6:r.j,reshape:r.k,reverse:o.bb,reverse1d:o.bc,reverse2d:o.bd,reverse3d:o.be,reverse4d:o.bf,round:o.bg,rsqrt:o.bh,scalar:r.n,selu:o.bi,separableConv2d:o.bj,setdiff1dAsync:o.bk,sigmoid:r.o,sign:o.bl,sin:o.bm,sinh:o.bn,slice:o.bo,slice1d:o.bp,slice2d:o.bq,slice3d:o.br,slice4d:o.bs,softmax:o.bt,softplus:o.bu,spaceToBatchND:o.bv,fft:o.bw,ifft:o.bx,irfft:o.by,rfft:o.bz,split:o.bA,sqrt:o.bB,square:o.bC,squaredDifference:o.bD,squeeze:o.bE,stack:o.bF,step:r.q,stridedSlice:o.bG,sub:o.bH,sum:r.t,tan:o.bI,tanh:o.bJ,tensor:r.v,tensor1d:o.bK,tensor2d:o.bL,tensor3d:o.bM,tensor4d:o.bN,tensor5d:o.bO,tensor6d:o.bP,tile:o.bQ,topk:o.bR,truncatedNormal:o.bS,unique:o.bT,unsortedSegmentSum:o.bU,unstack:o.bV,variable:o.bW,where:o.bX,whereAsync:o.bY,zeros:r.z,zerosLike:o.bZ,op:r.w,OP_SCOPE_SUFFIX:r.O,booleanMaskAsync:o.b_,transpose:o.b$,norm:o.c0,movingAverage:o.c1,scatterND:o.c2,sparseToDense:o.c3,gatherND:o.c4,dropout:o.c5,enclosingPowerOfTwo:o.c6,cosineWindow:o.c7,inTopKAsync:o.c8,image:o.c9,linalg:o.ca,losses:o.cb,spectral:o.cc,fused:o.cd,signal:o.ce,sparse:o.cf,string:o.cg,train:o.ch,enableProdMode:r.x,enableDebugMode:r.y,disableDeprecationWarnings:r.A,deprecationWarn:r.B,disposeVariables:r.C,engine:r.F,memory:r.G,profile:r.H,tidy:r.I,dispose:r.J,keep:r.L,time:r.M,setBackend:r.N,ready:r.P,getBackend:r.Q,removeBackend:r.S,findBackend:r.U,findBackendFactory:r.W,registerBackend:r.X,backend:r.Y,setPlatform:r.Z,getKernel:r._,getGradient:r.$,getKernelsForBackend:r.a0,registerKernel:r.a1,registerGradient:r.a2,unregisterKernel:r.a3,unregisterGradient:r.a4,copyRegisteredKernels:r.a5,Abs:r.a6,Acos:r.a7,Acosh:r.a8,Add:r.a9,AddN:r.aa,All:r.ab,Any:r.ac,ArgMax:r.ad,ArgMin:r.ae,Asin:r.af,Asinh:r.ag,Atan:r.ah,Atanh:r.ai,Atan2:r.aj,AvgPool:r.ak,AvgPoolGrad:r.al,AvgPool3D:r.am,AvgPool3DGrad:r.an,BatchMatMul:r.ao,BatchToSpaceND:r.ap,Bincount:r.aq,BroadcastTo:r.ar,Cast:r.as,Ceil:r.at,ClipByValue:r.au,Complex:r.av,ComplexAbs:r.aw,Concat:r.ax,Conv2D:r.ay,Conv2DBackpropFilter:r.az,Conv2DBackpropInput:r.aA,Conv3D:r.aB,Conv3DBackpropFilterV2:r.aC,Conv3DBackpropInputV2:r.aD,Cos:r.aE,Cosh:r.aF,Cumsum:r.aG,CropAndResize:r.aH,DenseBincount:r.aI,DepthToSpace:r.aJ,DepthwiseConv2dNative:r.aK,DepthwiseConv2dNativeBackpropFilter:r.aL,DepthwiseConv2dNativeBackpropInput:r.aM,Diag:r.aN,Dilation2D:r.aO,Dilation2DBackpropInput:r.aP,Dilation2DBackpropFilter:r.aQ,RealDiv:r.aR,Einsum:r.aS,Elu:r.aT,EluGrad:r.aU,Erf:r.aV,Equal:r.aW,Exp:r.aX,ExpandDims:r.aY,Expm1:r.aZ,FFT:r.a_,Fill:r.a$,FlipLeftRight:r.b0,Floor:r.b1,FloorDiv:r.b2,FusedBatchNorm:r.b3,GatherV2:r.b4,GatherNd:r.b5,Greater:r.b6,GreaterEqual:r.b7,Identity:r.b8,IFFT:r.b9,Imag:r.ba,IsFinite:r.bb,IsInf:r.bc,IsNan:r.bd,LeakyRelu:r.be,Less:r.bf,LessEqual:r.bg,LinSpace:r.bh,Log:r.bi,Log1p:r.bj,LogicalAnd:r.bk,LogicalNot:r.bl,LogicalOr:r.bm,LogSoftmax:r.bn,LRN:r.bo,LRNGrad:r.bp,Max:r.bq,Maximum:r.br,MaxPool:r.bs,MaxPoolGrad:r.bt,MaxPool3D:r.bu,MaxPool3DGrad:r.bv,MaxPoolWithArgmax:r.bw,Mean:r.bx,Min:r.by,Minimum:r.bz,MirrorPad:r.bA,Mod:r.bB,Multinomial:r.bC,Multiply:r.bD,Neg:r.bE,NotEqual:r.bF,NonMaxSuppressionV3:r.bG,NonMaxSuppressionV4:r.bH,NonMaxSuppressionV5:r.bI,OnesLike:r.bJ,OneHot:r.bK,Pack:r.bL,PadV2:r.bM,Pool:r.bN,Pow:r.bO,Prelu:r.bP,Prod:r.bQ,Range:r.bR,Real:r.bS,Reciprocal:r.bT,Relu:r.bU,Reshape:r.bV,ResizeNearestNeighbor:r.bW,ResizeNearestNeighborGrad:r.bX,ResizeBilinear:r.bY,ResizeBilinearGrad:r.bZ,Relu6:r.b_,Reverse:r.b$,Round:r.c0,Rsqrt:r.c1,ScatterNd:r.c2,Select:r.c3,Selu:r.c4,Slice:r.c5,Sin:r.c6,Sinh:r.c7,Sign:r.c8,Sigmoid:r.c9,Softplus:r.ca,Sqrt:r.cb,Sum:r.cc,SpaceToBatchND:r.cd,SplitV:r.ce,Softmax:r.cf,SparseFillEmptyRows:r.cg,SparseReshape:r.ch,SparseSegmentMean:r.ci,SparseSegmentSum:r.cj,SparseToDense:r.ck,SquaredDifference:r.cl,Square:r.cm,StridedSlice:r.cn,StringNGrams:r.co,StringSplit:r.cp,StringToHashBucketFast:r.cq,Sub:r.cr,Tan:r.cs,Tanh:r.ct,Tile:r.cu,TopK:r.cv,Transform:r.cw,Transpose:r.cx,Unique:r.cy,Unpack:r.cz,UnsortedSegmentSum:r.cA,ZerosLike:r.cB,Step:r.cC,FromPixels:r.cD,RotateWithOffset:r.cE,_FusedMatMul:r.cF,FusedConv2D:r.cG,FusedDepthwiseConv2D:r.cH,version_core:o.ci,browser:o.cj,io:o.ck,math:o.cl,serialization:o.cm,test_util:o.cn,util:r.cI,backend_util:r.cJ,tensor_util:r.cK,slice_util:r.cL,gather_util:r.cM,scatter_util:r.cN,device_util:r.cO,kernel_impls:o.co}));!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(n||(n={})),function(e){var t;(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(s||(s={}));const i={};function m(e){return i[e]}function u(e,t,a,n,s){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,p=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd;if("tensor"===o.type)return c(t.inputNames[o.inputIndexStart],a,n,s);if("tensors"===o.type)return t.inputNames.slice(e,p).map((e=>c(e,a,n,s)));const i=c(t.inputNames.slice(e)[0],a,n,s),m=i.dataSync();return"number"===o.type?m[0]:(0,r.cP)(i.shape,m)}const p=t.attrParams[e];return p&&p.value}function c(e,t,a,n){const[s,r]=y(e);if(null!=n){const e=n.getHashTableHandleByName(s);if(null!=e)return e}const o=a.currentContextIds.find((e=>!!t[l(s,e)]));return void 0!==o?t[l(s,o)][r]:void 0}function d(e,t){const[a,n,s]=y(e);return[l(a,t&&t.currentContextId),n,s]}function l(e,t){return t?`${e}-${t}`:e}function y(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const a=t[0],n=3===t.length?t[1]:void 0;return[a,Number(t[t.length-1]),n]}function h(e,t,a){let n=u("pad",e,t,a);if("explicit"===n){n=u("explicitPaddings",e,t,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=n[2*e],s[e][1]=n[2*e+1];return s}return n}function f(e){return e.kept?e:(0,r.f)(e)}var g=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),b=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),N=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]}),x=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]}),T=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]}),S=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),_=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]}),w=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]}),O=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]}),v=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]}),k=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),I=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]}),A=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]}),E=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]}),D=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]}),M=Object.freeze({__proto__:null,json:[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]}),V=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]}),z=Object.freeze({__proto__:null,json:[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]}),F=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class C{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[g,b,N,x,T,S,_,w,O,v,k,I,A,E,D,M,V,z,F].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const a=e.node,n=[],s=[],r=[],o=a.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e)),{});let p=[];const i=[];let m={},u={};null!=t&&(m=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const c=Object.keys(o);c.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,a)=>{const[n,,s]=d(e),r=o[n];if(null!=r.outputs){const e=r.outputs.indexOf(s);if(-1!==e){const s=`${n}:${e}`;t.inputNames[a]=s}}t.inputs.push(r),r.children.push(t)}))})),0===Object.keys(u).length?c.forEach((e=>{const t=o[e];0===t.children.length&&i.push(t)})):Object.keys(u).forEach((e=>{const[t]=d(e),a=o[t];null!=a&&(a.signatureKey=u[e],i.push(a))})),Object.keys(m).length>0?Object.keys(m).forEach((e=>{const[t]=d(e),a=o[t];a&&(a.signatureKey=m[e],p.push(a))})):p=n;let l={};null!=e.library&&null!=e.library.function&&(l=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const y={nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,signature:t,functions:l};return r.length>0&&(y.initNodes=r),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,a)=>(t[e[a].name]=a,t)),{})}mapNode(e){const t=m(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(a.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce(((t,a)=>{const n=a.type;let s;switch(a.type){case"string":s=$(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=$(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=K(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=K(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=B(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=B(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=U(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=U(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=R(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=R(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=X(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=X(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=W(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=W(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=Q(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Q(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=G(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=G(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=q(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=q(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=j(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=j(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:s,type:n},t}),{})),a}mapFunction(e){const t=e.nodeDef,a=[];let n={};null!=t&&(n=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e)),{}));const s=[],r=[];e.signature.inputArg.forEach((e=>{const[t]=d(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:P(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,s.push(a),n[t]=a})),Object.keys(n).forEach((e=>{const t=n[e];t.inputNames.forEach(((e,a)=>{const[s,,r]=d(e),o=n[s];if(null!=o.outputs){const e=o.outputs.indexOf(r);if(-1!==e){const n=`${s}:${e}`;t.inputNames[a]=n}}t.inputs.push(o),o.children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,a]=d(o[e.name]),s=n[t];null!=s&&(s.defaultOutput=a,r.push(s))}));const p=this.mapArgsToSignature(e);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function L(e,t){const a=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=(0,r.e)().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?a:a.toLowerCase()}function $(e,t,a,n=!1){const s=e[t];return null!=s?L(s.s,n):a}function R(e,t,a){const n=e[t];return n?n.b:a}function B(e,t,a){const n=e[t]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function P(e){switch("string"==typeof e&&(e=n[e]),e){case n.DT_FLOAT:return"float32";case n.DT_INT32:case n.DT_INT64:case n.DT_INT8:case n.DT_UINT8:return"int32";case n.DT_BOOL:return"bool";case n.DT_DOUBLE:return"float32";case n.DT_STRING:return"string";default:return null}}function j(e,t,a){const n=e[t];return n&&n.func?n.func.name:a}function G(e,t,a){const n=e[t];return n&&n.type?P(n.type):a}function q(e,t,a){const n=e[t];return n&&n.list&&n.list.type?n.list.type.map((e=>P(e))):a}function H(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function W(e,t,a){const n=e[t];return n&&n.shape?H(n.shape):a}function U(e,t,a){const n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):a}function K(e,t,a,n=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>L(e,n))):a}function Q(e,t,a){const n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map((e=>H(e))):a}function X(e,t,a){const n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class J{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return c(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return c(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return B(this.node.rawAttrs,e,t);if(null!=a.s)return $(this.node.rawAttrs,e,t);if(null!=a.b)return R(this.node.rawAttrs,e,t);if(null!=a.shape)return W(this.node.rawAttrs,e,t);if(null!=a.type)return G(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return U(this.node.rawAttrs,e,t);if(null!=a.list.s)return K(this.node.rawAttrs,e,t);if(null!=a.list.shape)return Q(this.node.rawAttrs,e,t);if(null!=a.list.b)return X(this.node.rawAttrs,e,t);if(null!=a.list.type)return q(this.node.rawAttrs,e,t)}return t}}function Y(e,t,a=""){if("number"!=typeof e&&"number"!=typeof t){(0,r.cQ)(e.length===t.length,(()=>a+` Shapes ${e} and ${t} must match`));for(let n=0;n<e.length;n++){const s=e[n],o=t[n];(0,r.cQ)(s<0||o<0||s===o,(()=>a+` Shapes ${e} and ${t} must match`))}}}function Z(e){return"number"!=typeof e&&!e.some((e=>e<0))}function ee(e,t,a){let n=te(e,a);const s=!Z(n);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(s&&t.forEach((e=>{n=te(e.shape,n)})),!Z(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function te(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const a=[];for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(s>=0&&r>=0&&s!==r)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=s>=0?s:r}return a}class ae{constructor(e,t,a,n,s,o,p){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=p,this.tensors=[],this.closed_=!1,this.idTensor=(0,r.n)(0),(0,r.L)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Y(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,(0,r.L)(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,a)=>this.write(e,t[a])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,r.v)([],[0].concat(this.elementShape));const a=this.readMany(e);return Y(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),(0,o.bF)(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,r.v)([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const a=this.readMany(t);return Y(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),(0,o.N)(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,(0,o.bV)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0;const n=e.map((e=>(a+=e,a)));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:t.size/a,p=[];(0,r.I)((()=>{t=(0,r.k)(t,[1,a,s]);for(let a=0;a<e.length;++a){const i=[0,0===a?0:n[a-1],0],m=[1,e[a],s];p[a]=(0,r.k)((0,o.bo)(t,i,m),this.elementShape)}return p}));const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,p)}}class ne{constructor(e,t,a,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach((e=>{if(a!==e.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);Y(t,e.shape,"TensorList shape mismatch: "),(0,r.L)(e)})),this.idTensor=(0,r.n)(0),this.maxNumElements=n,(0,r.L)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ne([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Y(e,this.elementShape,"TensorList shape mismatch: ");const n=ee(this.elementShape,this.tensors,e);return(0,r.I)((()=>{const e=this.tensors.map((e=>(0,r.k)(e,n)));return(0,o.bF)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=ee(this.elementShape,this.tensors,e),n=this.tensors.pop();return Y(n.shape,e,"TensorList shape mismatch: "),(0,r.k)(n,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Y(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,r.L)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Y(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=ee(this.elementShape,this.tensors,t);return(0,r.k)(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Y(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,r.L)(t),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Y(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=ee(this.elementShape,this.tensors,a);return 0===e.length?(0,r.v)([],[0].concat(n)):(0,r.I)((()=>{const t=e.map((e=>(0,r.k)(this.tensors[e],n)));return(0,o.bF)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Y(this.elementShape,t,"TensorList shape mismatch: ");const a=ee(this.elementShape,this.tensors,t);return 0===this.size()?(0,r.v)([],[0].concat(a)):(0,r.I)((()=>{const e=this.tensors.map((e=>(0,r.k)(e,a)));return(0,o.N)(e,0)}))}}function se(e,t,a){const[n,s]=u("fusedOps",e,t,a),r="biasadd"===n,o=!r,p="prelu"===s,i="fusedbatchnorm"===n,m=u("numArgs",e,t,a);if(r){if(p&&2!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!p&&r&&1!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=u("strides",e,t,a),d=h(e,t,a),l=u("dataFormat",e,t,a).toUpperCase(),y=u("dilations",e,t,a);let[f,g]=u("args",e,t,a);return o&&(g=f,f=void 0),{stride:c,pad:d,dataFormat:l,dilations:y,biasArg:f,preluArg:g,activationFunc:s,leakyreluAlpha:u("leakyreluAlpha",e,t,a)}}function re(e,t,a){return{boxes:u("boxes",e,t,a),scores:u("scores",e,t,a),maxOutputSize:u("maxOutputSize",e,t,a),iouThreshold:u("iouThreshold",e,t,a),scoreThreshold:u("scoreThreshold",e,t,a),softNmsSigma:u("softNmsSigma",e,t,a)}}class oe{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,r.n)(0),this.tensorMap=new Map,(0,r.L)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return(0,r.n)(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const a=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),(0,r.I)((()=>{const e=(0,o.bV)(t),n=a.length,s=e.length;(0,r.cQ)(n===s,(()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${s} elements.`));for(let t=0;t<n;t++){const n=a[t],s=e[t];(0,r.L)(s),this.tensorMap.set(n,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const a=await e.data();return(0,r.I)((()=>{const e=[];for(let n=0;n<a.length;n++){const s=a[n],r=this.findWithDefault(s,t);e.push(r)}return(0,o.bF)(e)}))}findWithDefault(e,t){const a=this.tensorMap.get(e);return null!=a?a:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function pe(e,t,a,n){const s=((e,t,a)=>{switch(e.category){case"arithmetic":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[(0,o.m)(u("a",e,t,a),u("b",e,t,a))];case"AddN":return[(0,o.o)(u("tensors",e,t,a))];case"FloorMod":case"Mod":return[(0,o.aO)(u("a",e,t,a),u("b",e,t,a))];case"Mul":return[(0,r.m)(u("a",e,t,a),u("b",e,t,a))];case"RealDiv":case"Div":return[(0,o.a6)(u("a",e,t,a),u("b",e,t,a))];case"DivNoNan":return[(0,o.a7)(u("a",e,t,a),u("b",e,t,a))];case"FloorDiv":return[(0,o.ai)(u("a",e,t,a),u("b",e,t,a))];case"Sub":return[(0,o.bH)(u("a",e,t,a),u("b",e,t,a))];case"Minimum":return[(0,o.aM)(u("a",e,t,a),u("b",e,t,a))];case"Maximum":return[(0,o.aI)(u("a",e,t,a),u("b",e,t,a))];case"Pow":return[(0,o.b2)(u("a",e,t,a),u("b",e,t,a))];case"SquaredDifference":return[(0,o.bD)(u("a",e,t,a),u("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"basic_math":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Abs":case"ComplexAbs":return[(0,o.j)(u("x",e,t,a))];case"Acos":return[(0,o.k)(u("x",e,t,a))];case"Acosh":return[(0,o.l)(u("x",e,t,a))];case"Asin":return[(0,o.t)(u("x",e,t,a))];case"Asinh":return[(0,o.u)(u("x",e,t,a))];case"Atan":return[(0,o.w)(u("x",e,t,a))];case"Atan2":return[(0,o.x)(u("x",e,t,a),u("y",e,t,a))];case"Atanh":return[(0,o.y)(u("x",e,t,a))];case"Ceil":return[(0,o.K)(u("x",e,t,a))];case"Complex":return[(0,r.g)(u("real",e,t,a),u("imag",e,t,a))];case"Cos":return[(0,o._)(u("x",e,t,a))];case"Cosh":return[(0,o.$)(u("x",e,t,a))];case"Elu":return[(0,r.h)(u("x",e,t,a))];case"Erf":return[(0,o.ab)(u("x",e,t,a))];case"Exp":return[(0,o.ac)(u("x",e,t,a))];case"Expm1":return[(0,o.ae)(u("x",e,t,a))];case"Floor":return[(0,o.ah)(u("x",e,t,a))];case"Log":return[(0,o.au)(u("x",e,t,a))];case"Log1p":return[(0,o.av)(u("x",e,t,a))];case"Imag":return[(0,o.am)(u("x",e,t,a))];case"Neg":return[(0,o.aS)(u("x",e,t,a))];case"Reciprocal":return[(0,o.ba)(u("x",e,t,a))];case"Real":return[(0,o.b9)(u("x",e,t,a))];case"Relu":return[(0,r.r)(u("x",e,t,a))];case"Round":return[(0,o.bg)(u("x",e,t,a))];case"Selu":return[(0,o.bi)(u("x",e,t,a))];case"Sigmoid":return[(0,r.o)(u("x",e,t,a))];case"Sin":return[(0,o.bm)(u("x",e,t,a))];case"Sign":return[(0,o.bl)(u("x",e,t,a))];case"Sinh":return[(0,o.bn)(u("x",e,t,a))];case"Softplus":return[(0,o.bu)(u("x",e,t,a))];case"Sqrt":return[(0,o.bB)(u("x",e,t,a))];case"Square":return[(0,o.bC)(u("x",e,t,a))];case"Tanh":return[(0,o.bJ)(u("x",e,t,a))];case"Tan":return[(0,o.bI)(u("x",e,t,a))];case"ClipByValue":return[(0,o.L)(u("x",e,t,a),u("clipValueMin",e,t,a),u("clipValueMax",e,t,a))];case"Relu6":return[(0,r.j)(u("x",e,t,a))];case"Rsqrt":return[(0,o.bh)(c(e.inputNames[0],t,a))];case"Prod":return[(0,o.b3)(u("x",e,t,a),u("axes",e,t,a))];case"LeakyRelu":return[(0,r.l)(u("x",e,t,a),u("alpha",e,t,a))];case"Prelu":return[(0,r.p)(u("x",e,t,a),u("alpha",e,t,a))];case"IsNan":return[(0,o.ap)(c(e.inputNames[0],t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"control":return(async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{const n=u("thenBranch",e,t,a),s=u("elseBranch",e,t,a),r=u("cond",e,t,a),o=u("args",e,t,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=u("body",e,t,a),s=u("cond",e,t,a),r=u("args",e,t,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),p=r.map((e=>e.id));let i=await o[0].data();o.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||e.dispose()}));let m=r;for(;i[0];){const e=m;m=await a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);const t=m.map((e=>e.id));e.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const r=await a.functionMap[s].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);i=await r[0].data(),r.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return m}case"LoopCond":return[f(u("pred",e,t,a))];case"Switch":{const n=u("pred",e,t,a);let s=u("data",e,t,a);return s.kept||(s=f(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=e.inputNames.find((e=>void 0!==c(e,t,a)));return n?[f(c(n,t,a))]:void 0}case"Enter":{const n=u("frameName",e,t,a),s=u("tensor",e,t,a);return a.enterFrame(n),[f(s)]}case"Exit":{const n=u("tensor",e,t,a);return a.exitFrame(),[f(n)]}case"NextIteration":{const n=u("tensor",e,t,a);return a.nextIteration(),[f(n)]}case"TensorArrayV3":{const n=u("size",e,t,a),s=u("dtype",e,t,a),o=u("elementShape",e,t,a),p=u("dynamicSize",e,t,a),i=u("clearAfterRead",e,t,a),m=u("identicalElementShapes",e,t,a),c=u("name",e,t,a),d=new ae(c,s,n,o,m,p,i);return a.addTensorArray(d),[d.idTensor,(0,r.n)(1)]}case"TensorArrayWriteV3":{const n=u("tensorArrayId",e,t,a),s=u("index",e,t,a),r=u("tensor",e,t,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=u("tensorArrayId",e,t,a),s=u("index",e,t,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=u("tensorArrayId",e,t,a),s=u("indices",e,t,a),r=u("dtype",e,t,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=u("tensorArrayId",e,t,a),s=u("indices",e,t,a),r=u("tensor",e,t,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=u("tensorArrayId",e,t,a),s=a.getTensorArray(n.id),r=u("dtype",e,t,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=u("tensorArrayId",e,t,a),s=u("tensor",e,t,a),r=u("lengths",e,t,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const n=u("tensorArrayId",e,t,a),s=a.getTensorArray(n.id);return[(0,r.n)(s.size(),"int32")]}case"TensorArrayCloseV3":{const n=u("tensorArrayId",e,t,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=u("tensorListId",e,t,a),s=u("index",e,t,a),r=u("tensor",e,t,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=u("tensorListId",e,t,a),s=u("index",e,t,a),r=u("elementShape",e,t,a),o=u("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=u("indices",e,t,a),s=function(e,t,a,n){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const r=new ne([],a,e.dtype,n),p=(0,o.bV)(e,0);return t.forEach(((e,t)=>{r.setItem(e,p[t])})),r}(u("tensor",e,t,a),n,u("elementShape",e,t,a),u("numElements",e,t,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=u("elementShape",e,t,a),s=u("elementDType",e,t,a);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=function(e,t,a){return new ne([],e,t,a)}(n,s,u(r,e,t,a));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=u("tensorListId",e,t,a),s=u("indices",e,t,a),r=u("elementShape",e,t,a),o=u("elementDType",e,t,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=u("tensorListId",e,t,a),s=u("elementShape",e,t,a),r=u("elementDType",e,t,a),o=u("numElements",e,t,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(e,t,a){const n=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);Y(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=(0,o.bV)(e);return new ne(s,t,n)}(u("tensor",e,t,a),u("elementShape",e,t,a),u("elementDType",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=u("tensorListId",e,t,a),s=a.getTensorList(n.id),r=u("dtype",e,t,a),o=u("elementShape",e,t,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=u("tensorListId",e,t,a),s=u("tensor",e,t,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=u("tensorListId",e,t,a),s=u("elementShape",e,t,a),r=u("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=u("tensor",e,t,a),s=u("elementShape",e,t,a),p=function(e,t,a){let n=0;const s=t.map((e=>(n+=e,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);const p=te(e.shape.slice(1),a),i=0===n?0:e.size/n,m=(0,r.I)((()=>{const a=[];e=(0,r.k)(e,[1,n,i]);for(let n=0;n<t.length;++n){const m=[0,0===n?0:s[n-1],0],u=[1,t[n],i];a[n]=(0,r.k)((0,o.bo)(e,m,u),p)}return e.dispose(),a})),u=new ne([],a,e.dtype,t.length);for(let e=0;e<m.length;e++)u.setItem(e,m[e]);return u}(n,u("lengths",e,t,a),s);return a.addTensorList(p),[p.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a);case"convolution":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Conv1D":{const n=u("stride",e,t,a),s=u("pad",e,t,a),r=u("dataFormat",e,t,a).toUpperCase(),p=u("dilation",e,t,a);return[(0,o.V)(u("x",e,t,a),u("filter",e,t,a),n,s,r,p)]}case"Conv2D":{const n=u("strides",e,t,a),s=h(e,t,a),r=u("dataFormat",e,t,a).toUpperCase(),p=u("dilations",e,t,a);return[(0,o.W)(u("x",e,t,a),u("filter",e,t,a),[n[1],n[2]],s,r,[p[1],p[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:p,biasArg:i,preluArg:m,activationFunc:c,leakyreluAlpha:d}=se(e,t,a);return[(0,o.cq)({x:u("x",e,t,a),filter:u("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[p[1],p[2]],bias:i,activation:c,preluActivationWeights:m,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:p,biasArg:i,preluArg:m,activationFunc:c,leakyreluAlpha:d}=se(e,t,a);return[(0,o.cp)({x:u("x",e,t,a),filter:u("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[p[1],p[2]],bias:i,activation:c,preluActivationWeights:m,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=u("outputShape",e,t,a),s=u("strides",e,t,a),r=h(e,t,a);return[(0,o.X)(u("x",e,t,a),u("filter",e,t,a),n,[s[1],s[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=u("strides",e,t,a),s=h(e,t,a),r=u("dilations",e,t,a),p=u("dataFormat",e,t,a).toUpperCase();return[(0,o.a3)(u("input",e,t,a),u("filter",e,t,a),[n[1],n[2]],s,p,[r[1],r[2]])]}case"Conv3D":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("dataFormat",e,t,a).toUpperCase(),p=u("dilations",e,t,a);return[(0,o.Y)(u("x",e,t,a),u("filter",e,t,a),[n[1],n[2],n[3]],s,r,[p[1],p[2],p[3]])]}case"AvgPool":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("kernelSize",e,t,a);return[(0,o.z)(u("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("kernelSize",e,t,a);return[(0,o.aF)(u("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("kernelSize",e,t,a),p=u("includeBatchInIndex",e,t,a),{result:i,indexes:m}=(0,o.aH)(u("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s,p);return[i,m]}case"AvgPool3D":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("kernelSize",e,t,a);return[(0,o.B)(u("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("kernelSize",e,t,a);return[(0,o.aG)(u("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=u("strides",e,t,a),s=u("pad",e,t,a),r=u("dilations",e,t,a),p=n[1],i=n[2],m=r[1],c=r[2];return[(0,o.a5)(u("x",e,t,a),u("filter",e,t,a),[p,i],s,[m,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"creation":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Fill":{const n=u("shape",e,t,a),s=u("dtype",e,t,a),r=u("value",e,t,a);return[(0,o.ag)(n,r,s)]}case"LinSpace":{const n=u("start",e,t,a),s=u("stop",e,t,a),r=u("num",e,t,a);return[(0,o.as)(n,s,r)]}case"Multinomial":{const n=u("logits",e,t,a),s=u("numSamples",e,t,a),r=u("seed",e,t,a);return[(0,o.aR)(n,s,r)]}case"OneHot":{const n=u("indices",e,t,a),s=u("depth",e,t,a),r=u("onValue",e,t,a),p=u("offValue",e,t,a);return[(0,o.aU)(n,s,r,p)]}case"Ones":return[(0,o.aV)(u("shape",e,t,a),u("dtype",e,t,a))];case"OnesLike":return[(0,o.aW)(u("x",e,t,a))];case"RandomUniform":return[(0,o.b7)(u("shape",e,t,a),u("minval",e,t,a),u("maxval",e,t,a),u("dtype",e,t,a))];case"Range":{const n=u("start",e,t,a),s=u("stop",e,t,a),r=u("step",e,t,a);return[(0,o.b8)(n,s,r,u("dtype",e,t,a))]}case"TruncatedNormal":{const n=u("shape",e,t,a),s=u("mean",e,t,a),r=u("stdDev",e,t,a),p=u("seed",e,t,a);return[(0,o.bS)(n,s,r,u("dtype",e,t,a),p)]}case"Zeros":return[(0,r.z)(u("shape",e,t,a),u("dtype",e,t,a))];case"ZerosLike":return[(0,o.bZ)(u("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"dynamic":return(async(e,t,a)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:p,scoreThreshold:i,softNmsSigma:m}=re(e,t,a),u=await o.c9.nonMaxSuppressionWithScoreAsync(n,s,r,p,i,m);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:p,scoreThreshold:i}=re(e,t,a),m=u("padToMaxOutputSize",e,t,a),c=await o.c9.nonMaxSuppressionPaddedAsync(n,s,r,p,i,m);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:p,scoreThreshold:i}=re(e,t,a);return[await o.c9.nonMaxSuppressionAsync(n,s,r,p,i)]}case"Where":{const n=(0,r.d)(u("condition",e,t,a),"bool"),s=[await(0,o.bY)(n)];return n.dispose(),s}case"ListDiff":return(0,o.bk)(u("x",e,t,a),u("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a);case"evaluation":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"TopKV2":{const n=u("x",e,t,a),s=u("k",e,t,a),r=u("sorted",e,t,a),p=(0,o.bR)(n,s,r);return[p.values,p.indices]}case"Unique":{const n=u("x",e,t,a),s=(0,o.bT)(n);return[s.values,s.indices]}case"UniqueV2":{const n=u("x",e,t,a),s=u("axis",e,t,a),r=(0,o.bT)(n,s);return[r.values,r.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"image":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"ResizeBilinear":{const n=u("images",e,t,a),s=u("size",e,t,a),r=u("alignCorners",e,t,a),p=u("halfPixelCenters",e,t,a);return[o.c9.resizeBilinear(n,[s[0],s[1]],r,p)]}case"ResizeNearestNeighbor":{const n=u("images",e,t,a),s=u("size",e,t,a),r=u("alignCorners",e,t,a),p=u("halfPixelCenters",e,t,a);return[o.c9.resizeNearestNeighbor(n,[s[0],s[1]],r,p)]}case"CropAndResize":{const n=u("image",e,t,a),s=u("boxes",e,t,a),r=u("boxInd",e,t,a),p=u("cropSize",e,t,a),i=u("method",e,t,a),m=u("extrapolationValue",e,t,a);return[o.c9.cropAndResize(n,s,r,p,i,m)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"graph":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const n=u("default",e,t,a);return[c(e.name,t,a)||n];case"Placeholder":return[c(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[f(u("x",e,t,a))];case"IdentityN":return u("x",e,t,a).map((e=>f(e)));case"Snapshot":return[f(u("x",e,t,a))];case"Shape":return[(0,o.bK)(u("x",e,t,a).shape,"int32")];case"ShapeN":return u("x",e,t,a).map((e=>(0,o.bK)(e.shape)));case"Size":return[(0,r.n)(u("x",e,t,a).size,"int32")];case"Rank":return[(0,r.n)(u("x",e,t,a).rank,"int32")];case"NoOp":return[(0,r.n)(1)];case"Print":const s=u("x",e,t,a),p=u("data",e,t,a),i=u("message",e,t,a),m=u("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<p.length;e++)console.log(Array.prototype.slice.call(p[e].dataSync()).slice(0,m));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"logical":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Equal":return[(0,o.aa)(u("a",e,t,a),u("b",e,t,a))];case"NotEqual":return[(0,o.aT)(u("a",e,t,a),u("b",e,t,a))];case"Greater":return[(0,o.ak)(u("a",e,t,a),u("b",e,t,a))];case"GreaterEqual":return[(0,o.al)(u("a",e,t,a),u("b",e,t,a))];case"Less":return[(0,o.aq)(u("a",e,t,a),u("b",e,t,a))];case"LessEqual":return[(0,o.ar)(u("a",e,t,a),u("b",e,t,a))];case"LogicalAnd":return[(0,o.az)(u("a",e,t,a),u("b",e,t,a))];case"LogicalNot":return[(0,o.aA)(u("a",e,t,a))];case"LogicalOr":return[(0,o.aB)(u("a",e,t,a),u("b",e,t,a))];case"Select":case"SelectV2":return[(0,o.bX)(u("condition",e,t,a),u("a",e,t,a),u("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"matrices":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[(0,o.aD)(u("a",e,t,a),u("b",e,t,a),u("transposeA",e,t,a),u("transposeB",e,t,a))];case"Einsum":return[(0,o.a9)(u("equation",e,t,a),...u("tensors",e,t,a))];case"Transpose":return[(0,o.b$)(u("x",e,t,a),u("perm",e,t,a))];case"_FusedMatMul":const[n,s]=u("fusedOps",e,t,a),r="biasadd"===n,p="prelu"===s,i=u("numArgs",e,t,a),m=u("leakyreluAlpha",e,t,a);if(r){if(p&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!p&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=u("args",e,t,a);return[(0,o.cr)({a:u("a",e,t,a),b:u("b",e,t,a),transposeA:u("transposeA",e,t,a),transposeB:u("transposeB",e,t,a),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:m})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"normalization":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[(0,o.E)(u("x",e,t,a),u("mean",e,t,a),u("variance",e,t,a),u("offset",e,t,a),u("scale",e,t,a),u("epsilon",e,t,a))];case"LRN":return[(0,o.at)(u("x",e,t,a),u("radius",e,t,a),u("bias",e,t,a),u("alpha",e,t,a),u("beta",e,t,a))];case"Softmax":return[(0,o.bt)(u("x",e,t,a))];case"LogSoftmax":return[(0,o.ax)(u("x",e,t,a))];case"SparseToDense":return[(0,o.c3)(u("sparseIndices",e,t,a),u("outputShape",e,t,a),u("sparseValues",e,t,a),u("defaultValue",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"reduction":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Max":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.aE)(u("x",e,t,a),n,s)]}case"Mean":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.aJ)(u("x",e,t,a),n,s)]}case"Min":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.aL)(u("x",e,t,a),n,s)]}case"Sum":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,r.t)(u("x",e,t,a),n,s)]}case"All":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.p)(u("x",e,t,a),n,s)]}case"Any":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.q)(u("x",e,t,a),n,s)]}case"ArgMax":{const n=u("axis",e,t,a);return[(0,o.r)(u("x",e,t,a),n)]}case"ArgMin":{const n=u("axis",e,t,a);return[(0,o.s)(u("x",e,t,a),n)]}case"Prod":{const n=u("axis",e,t,a),s=u("keepDims",e,t,a);return[(0,o.b3)(u("x",e,t,a),n,s)]}case"Cumsum":{const n=u("axis",e,t,a),s=u("exclusive",e,t,a),r=u("reverse",e,t,a);return[(0,o.a0)(u("x",e,t,a),n,s,r)]}case"Bincount":const n=u("x",e,t,a),s=u("weights",e,t,a),p=u("size",e,t,a);return[(0,o.I)(n,s,p)];case"DenseBincount":{const n=u("x",e,t,a),s=u("weights",e,t,a),r=u("size",e,t,a),p=u("binaryOutput",e,t,a);return[(0,o.a1)(n,s,r,p)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"slice_join":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"ConcatV2":case"Concat":{const n=u("n",e,t,a),s=u("axis",e,t,a);let r=u("tensors",e,t,a);return r=r.slice(0,n),[(0,o.N)(r,s)]}case"Gather":{const n=u("x",e,t,a),s=u("indices",e,t,a);return[(0,o.aj)(n,(0,r.d)(s,"int32"),0)]}case"GatherV2":{const n=u("axis",e,t,a),s=u("batchDims",e,t,a),p=u("x",e,t,a),i=u("indices",e,t,a);return[(0,o.aj)(p,(0,r.d)(i,"int32"),n,s)]}case"Reverse":{const n=u("dims",e,t,a),s=[];for(let e=0;e<n.length;e++)n[e]&&s.push(e);const r=u("x",e,t,a);return[(0,o.bb)(r,s)]}case"ReverseV2":{const n=u("axis",e,t,a),s=u("x",e,t,a);return[(0,o.bb)(s,n)]}case"Slice":{const n=u("begin",e,t,a),s=u("size",e,t,a);return[(0,o.bo)(u("x",e,t,a),n,s)]}case"StridedSlice":{const n=u("begin",e,t,a),s=u("end",e,t,a),r=u("strides",e,t,a),p=u("beginMask",e,t,a),i=u("endMask",e,t,a),m=u("ellipsisMask",e,t,a),c=u("newAxisMask",e,t,a),d=u("shrinkAxisMask",e,t,a),l=u("x",e,t,a);return[(0,o.bG)(l,n,s,r,p,i,m,c,d)]}case"Pack":return(0,r.I)((()=>{const n=u("axis",e,t,a),s=u("tensors",e,t,a),p=s[0].shape,i=(0,o.bE)(s[0]).shape,m=s.map((e=>{const t=(0,r.cR)(e.shape,p);if(!t&&!(0,r.cR)((0,o.bE)(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:(0,r.k)(e,p)}));return[(0,o.bF)(m,n)]}));case"Unpack":{const n=u("axis",e,t,a),s=u("tensor",e,t,a);return(0,o.bV)(s,n)}case"Tile":{const n=u("reps",e,t,a);return[(0,o.bQ)(u("x",e,t,a),n)]}case"Split":case"SplitV":{const n=u("axis",e,t,a),s=u("numOrSizeSplits",e,t,a),r=u("x",e,t,a);return(0,o.bA)(r,s,n)}case"ScatterNd":{const n=u("indices",e,t,a),s=u("values",e,t,a),r=u("shape",e,t,a);return[(0,o.c2)(n,s,r)]}case"GatherNd":{const n=u("x",e,t,a),s=u("indices",e,t,a);return[(0,o.c4)(n,s)]}case"SparseToDense":{const n=u("sparseIndices",e,t,a),s=u("outputShape",e,t,a),p=u("sparseValues",e,t,a),i=u("defaultValue",e,t,a);return[(0,o.c3)(n,p,s,p.dtype===i.dtype?i:(0,r.d)(i,p.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"sparse":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:n,outputValues:s,emptyRowIndicator:r,reverseIndexMap:p}=o.cf.sparseFillEmptyRows(u("indices",e,t,a),u("values",e,t,a),u("denseShape",e,t,a),u("defaultValue",e,t,a));return[n,s,r,p]}case"SparseReshape":{const{outputIndices:n,outputShape:s}=o.cf.sparseReshape(u("inputIndices",e,t,a),u("inputShape",e,t,a),u("newShape",e,t,a));return[n,s]}case"SparseSegmentMean":return[o.cf.sparseSegmentMean(u("data",e,t,a),u("indices",e,t,a),u("segmentIds",e,t,a))];case"SparseSegmentSum":return[o.cf.sparseSegmentSum(u("data",e,t,a),u("indices",e,t,a),u("segmentIds",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"spectral":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"FFT":return[(0,o.bw)(u("x",e,t,a))];case"IFFT":return[(0,o.bx)(u("x",e,t,a))];case"RFFT":return[(0,o.bz)(u("x",e,t,a))];case"IRFFT":return[(0,o.by)(u("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"string":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"StringNGrams":{const{nGrams:n,nGramsSplits:s}=o.cg.stringNGrams(u("data",e,t,a),u("dataSplits",e,t,a),u("separator",e,t,a),u("nGramWidths",e,t,a),u("leftPad",e,t,a),u("rightPad",e,t,a),u("padWidth",e,t,a),u("preserveShortSequences",e,t,a));return[n,s]}case"StringSplit":{const{indices:n,values:s,shape:r}=o.cg.stringSplit(u("input",e,t,a),u("delimiter",e,t,a),u("skipEmpty",e,t,a));return[n,s,r]}case"StringToHashBucketFast":return[o.cg.stringToHashBucketFast(u("input",e,t,a),u("numBuckets",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"transformation":return(0,r.I)((()=>((e,t,a)=>{switch(e.op){case"Cast":return[(0,r.d)(u("x",e,t,a),u("dtype",e,t,a))];case"ExpandDims":{const n=u("axis",e,t,a);return[(0,o.ad)(u("x",e,t,a),n)]}case"Squeeze":{const n=u("axis",e,t,a);return[(0,o.bE)(u("x",e,t,a),n)]}case"Reshape":return[(0,r.k)(u("x",e,t,a),u("shape",e,t,a))];case"MirrorPad":return[(0,o.aN)(u("x",e,t,a),u("padding",e,t,a),u("mode",e,t,a))];case"PadV2":case"Pad":return[(0,o.aY)(u("x",e,t,a),u("padding",e,t,a),u("constantValue",e,t,a))];case"SpaceToBatchND":{const n=u("blockShape",e,t,a),s=u("paddings",e,t,a);return[(0,o.bv)(u("x",e,t,a),n,s)]}case"BatchToSpaceND":{const n=u("blockShape",e,t,a),s=u("crops",e,t,a);return[(0,o.D)(u("x",e,t,a),n,s)]}case"DepthToSpace":{const n=u("blockSize",e,t,a),s=u("dataFormat",e,t,a).toUpperCase();return[(0,o.a2)(u("x",e,t,a),n,s)]}case"BroadcastTo":return[(0,o.J)(u("x",e,t,a),u("shape",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a)));case"hash_table":return(async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=u("keyDType",e,t,a),r=u("valueDType",e,t,a),o=new oe(s,r);return n.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=u("tableHandle",e,t,a,n),r=u("keys",e,t,a),o=u("values",e,t,a),p=n.getHashTableById(s.id);return[await p.import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=u("tableHandle",e,t,a,n),r=u("keys",e,t,a),o=u("defaultValue",e,t,a),p=n.getHashTableById(s.id);return[await p.find(r,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=u("tableHandle",e,t,a,n);return[n.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,a,n);case"custom":const s=m(e.op);if(s&&s.customExecutor)return s.customExecutor(new J(e,t,a));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,a);return(0,r.cS)(s)?s.then((e=>[].concat(e))):[].concat(s)}class ie{constructor(e={},t={},a={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function me(e,t,a,n){const s=new Set,r=[];let o=null,p=null;const i=new Set,m=Object.keys(e).map((e=>y(e)[0]));let u=[];null!=n&&(u=n.map((e=>y(e.name)[0])));const c=[...t];for(;c.length>0;){const e=c.pop();(le(e)||ye(e)||he(e))&&null==o&&(o=e,p=o.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==a[e.name]&&-1===m.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{i.has(e.name)||(i.add(e.name),c.push(e))})):r.push(e.name))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:o,syncInputs:p}}const ue=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ce=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],de=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function le(e){return ue.indexOf(e.op)>=0}function ye(e){return ce.indexOf(e.op)>=0}function he(e){return de.indexOf(e.op)>=0}class fe{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new fe(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const a=e.map((e=>e.name)).sort(),n=t.map((e=>e.name)).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){const a=me(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(e,t,a){const{usedNodes:n,inputs:s}=a,r=[],o=Object.keys(s).map((e=>y(e)[0])).map((t=>e.nodes[t])),p=e.initNodes;o.forEach((e=>{n.has(e.name)&&r.push(e)})),e.weights.forEach((e=>{n.has(e.name)&&r.push(e)})),null!=p&&p.forEach((e=>{n.has(e.name)&&r.push(e)}));const i=new Set,m=[];for(;r.length>0;){const e=r.pop();i.add(e.name),t[e.name]||m.push(e),e.children.forEach((e=>{!i.has(e.name)&&n.has(e.name)&&e.inputs.every((e=>i.has(e.name)))&&r.push(e)}))}return m}(this.graph,this.weightMap,a)}execute(e,t){e=this.mapInputs(e);const a=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const n=a.map((e=>this.graph.nodes[y(e)[0]])),s=t.map((e=>y(e)[0]));let o=s.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);const p=this.getCompilationKey(n,o);let i=this.compiledMap.get(p);null==i&&(i=this.compile(e,o),this.compiledMap.set(p,i));const m={},u={};return(0,r.I)((()=>{const a=new ie(this.weightMap,m,u,this.functionExecutorMap),n=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[a,s]=y(t),r=[];r[s]=e[t],n[a]=r}));const o=this.getFrozenTensorIds(n),p={};for(let e=0;e<i.length;e++){const t=i[e];if(!n[t.name]){const e=pe(t,n,a,this._resourceManager);if((0,r.cS)(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);n[t.name]=e,this.checkTensorForDisposal(t.name,t,n,a,o,s,p)}}return null==this.parent&&a.dispose(o),t.map((e=>c(e,n,a)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,a,n,s,r,o){"control"!==t.category&&-1===r.indexOf(e)&&(a[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,a){return t[l(e,a.currentContextId)]}(e.name,a,n);null!=t&&t.forEach((e=>{if(e&&!e.kept&&!s.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,a=!1,n={},s={}){a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const r=new ie(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(e,r,t,a),p=t.map((e=>c(e,o,r))),i=p.map((e=>e.id)),m=Object.keys(e).map((t=>e[t].id)),u=new Set([...i,...m,...this.weightIds]);return Object.keys(o).forEach((e=>{o[e].forEach((e=>{!e||e.kept||e.isDisposed||u.has(e.id)||e.dispose()}))})),null==this.parent&&r.dispose(u),p}async executeFunctionAsync(e,t,a){const n=e.reduce(((e,t,a)=>(e[this.inputs[a].name]=t,e)),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){const s=Object.keys(e),r=s.map((e=>this.graph.nodes[y(e)[0]])),o=a.map((e=>y(e)[0]));let p=o.map((e=>this.graph.nodes[e]));0===p.length&&(p=this._outputs);const{usedNodes:i,missingInputs:m,dynamicNode:u,syncInputs:d}=me(e,p,this.weightMap,this._initNodes),l=[...r,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[a,n]=y(t),s=[];s[n]=e[t],h[a]=s}));const f={},g=this.getFrozenTensorIds(h),b={};for(;l.length>0;){const e=this.processStack(r,l,t,h,b,g,o,f,i);await Promise.all(e)}null!=u||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=p.filter((e=>!le(e)&&!c(e.name,h,t))).map((e=>e.name));if(N.length>0){let e="";throw null!=u&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${e}`)}return h}processStack(e,t,a,n,s,o,p,i,m){const c=[];for(;t.length>0;){const e=t.pop();a.currentContext=e.contexts;let l="";if("Enter"===e.node.op&&u("isConstant",e.node,n,a)&&([l]=d(e.node.name,a)),null==n[e.node.name]){const u=pe(e.node,n,a,this._resourceManager);l||([l]=d(e.node.name,a));const y=a.currentContext;(0,r.cS)(u)?c.push(u.then((r=>(n[l]=r,a.currentContext=y,this.checkTensorForDisposal(l,e.node,n,a,o,p,i),this.processChildNodes(e.node,t,a,n,s,m),r)))):(n[l]=u,this.checkTensorForDisposal(l,e.node,n,a,o,p,i),this.processChildNodes(e.node,t,a,n,s,m))}else this.processChildNodes(e.node,t,a,n,s,m)}return c}processChildNodes(e,t,a,n,s,r){e.children.forEach((e=>{const[o]=d(e.name,a);!s[o]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!c(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every((e=>!!c(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const a=e[t],[n]=y(t),s=this.graph.nodes[n];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value,t=e.length===a.shape.length&&a.shape.every(((t,a)=>-1===e[a]||e[a]===t));(0,r.cQ)(t,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${a.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&(0,r.cQ)(a.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`))}))}mapInputs(e){const t={};for(const a in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]?t[this._signature.inputs[a].name]=e[a]:t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=y(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{const[t]=y(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class ge{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class be{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new ge}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=(0,r.cT)(e,this.loadOptions);else{const t=(0,r.cU)(e,this.loadOptions);if(0===t.length)t.push((0,r.cT)(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let a;a=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=a,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const n=(0,r.cV)(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new fe(C.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=C.Instance.transformGraph(e.modelInitializer);this.initializer=new fe(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=(0,r.cW)(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof r.T||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,a,n)=>(t[a]=e[n],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,a)=>(t[a]=[e[a]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Ne(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const a=new be(e,t);return await a.load(),a}function xe(e,t,a,n){return new(a||(a=Promise))((function(s,r){function o(e){try{i(n.next(e))}catch(e){r(e)}}function p(e){try{i(n.throw(e))}catch(e){r(e)}}function i(e){e.done?s(e.value):new a((function(t){t(e.value)})).then(o,p)}i((n=n.apply(e,t||[])).next())}))}function Te(e,t){var a,n,s,r,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return r={next:p(0),throw:p(1),return:p(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function p(r){return function(p){return function(r){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,n&&(s=2&r[0]?n.return:r[0]?n.throw||((s=n.return)&&s.call(n),0):n.next)&&!(s=s.call(n,r[1])).done)return s;switch(n=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,n=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!(s=(s=o.trys).length>0&&s[s.length-1])&&(6===r[0]||2===r[0])){o=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){o.label=r[1];break}if(6===r[0]&&o.label<s[1]){o.label=s[1],s=r;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(r);break}s[2]&&o.ops.pop(),o.trys.pop();continue}r=t.call(e,o)}catch(e){r=[6,e],n=0}finally{a=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,p])}}}var Se=[[0,0,0],[120,120,120],[180,120,120],[6,230,230],[80,50,50],[4,200,3],[120,120,80],[140,140,140],[204,5,255],[230,230,230],[4,250,7],[224,5,255],[235,255,7],[150,5,61],[120,120,70],[8,255,51],[255,6,82],[143,255,140],[204,255,4],[255,51,7],[204,70,3],[0,102,200],[61,230,250],[255,6,51],[11,102,255],[255,7,71],[255,9,224],[9,7,230],[220,220,220],[255,9,92],[112,9,255],[8,255,214],[7,255,224],[255,184,6],[10,255,71],[255,41,10],[7,255,255],[224,255,8],[102,8,255],[255,61,6],[255,194,7],[255,122,8],[0,255,20],[255,8,41],[255,5,153],[6,51,255],[235,12,255],[160,150,20],[0,163,255],[140,140,140],[250,10,15],[20,255,0],[31,255,0],[255,31,0],[255,224,0],[153,255,0],[0,0,255],[255,71,0],[0,235,255],[0,173,255],[31,0,255],[11,200,200],[255,82,0],[0,255,245],[0,61,255],[0,255,112],[0,255,133],[255,0,0],[255,163,0],[255,102,0],[194,255,0],[0,143,255],[51,255,0],[0,82,255],[0,255,41],[0,255,173],[10,0,255],[173,255,0],[0,255,153],[255,92,0],[255,0,255],[255,0,245],[255,0,102],[255,173,0],[255,0,20],[255,184,184],[0,31,255],[0,255,61],[0,71,255],[255,0,204],[0,255,194],[0,255,82],[0,10,255],[0,112,255],[51,0,255],[0,194,255],[0,122,255],[0,255,163],[255,153,0],[0,255,10],[255,112,0],[143,255,0],[82,0,255],[163,255,0],[255,235,0],[8,184,170],[133,0,255],[0,255,92],[184,0,255],[255,0,31],[0,184,255],[0,214,255],[255,0,112],[92,255,0],[0,224,255],[112,224,255],[70,184,160],[163,0,255],[153,0,255],[71,255,0],[255,0,163],[255,204,0],[255,0,143],[0,255,235],[133,255,0],[255,0,235],[245,0,255],[255,0,122],[255,245,0],[10,190,212],[214,255,0],[0,204,255],[20,0,255],[255,255,0],[0,153,255],[0,41,255],[0,255,204],[41,0,255],[41,255,0],[173,0,255],[0,245,255],[71,0,255],[122,0,255],[0,255,184],[0,92,255],[184,255,0],[0,133,255],[255,214,0],[25,194,194],[102,255,0],[92,0,255]],_e=[[128,64,128],[244,35,232],[70,70,70],[102,102,156],[190,153,153],[153,153,153],[250,170,30],[220,220,0],[107,142,35],[152,251,152],[70,130,180],[220,20,60],[255,0,0],[0,0,142],[0,0,70],[0,60,100],[0,80,100],[0,0,230],[119,11,32]],we=[[0,0,0],[128,0,0],[0,128,0],[128,128,0],[0,0,128],[128,0,128],[0,128,128],[128,128,128],[64,0,0],[192,0,0],[64,128,0],[192,128,0],[64,0,128],[192,0,128],[64,128,128],[192,128,128],[0,64,0],[128,64,0],[0,192,0],[128,192,0],[0,64,128],[128,64,128],[0,192,128],[128,192,128],[64,64,0],[192,64,0],[64,192,0],[192,192,0],[64,64,128],[192,64,128],[64,192,128],[192,192,128],[0,0,64],[128,0,64],[0,128,64],[128,128,64],[0,0,192],[128,0,192],[0,128,192],[128,128,192],[64,0,64],[192,0,64],[64,128,64],[192,128,64],[64,0,192],[192,0,192],[64,128,192],[192,128,192],[0,64,64],[128,64,64],[0,192,64],[128,192,64],[0,64,192],[128,64,192],[0,192,192],[128,192,192],[64,64,64],[192,64,64],[64,192,64],[192,192,64],[64,64,192],[192,64,192],[64,192,192],[192,192,192],[32,0,0],[160,0,0],[32,128,0],[160,128,0],[32,0,128],[160,0,128],[32,128,128],[160,128,128],[96,0,0],[224,0,0],[96,128,0],[224,128,0],[96,0,128],[224,0,128],[96,128,128],[224,128,128],[32,64,0],[160,64,0],[32,192,0],[160,192,0],[32,64,128],[160,64,128],[32,192,128],[160,192,128],[96,64,0],[224,64,0],[96,192,0],[224,192,0],[96,64,128],[224,64,128],[96,192,128],[224,192,128],[32,0,64],[160,0,64],[32,128,64],[160,128,64],[32,0,192],[160,0,192],[32,128,192],[160,128,192],[96,0,64],[224,0,64],[96,128,64],[224,128,64],[96,0,192],[224,0,192],[96,128,192],[224,128,192],[32,64,64],[160,64,64],[32,192,64],[160,192,64],[32,64,192],[160,64,192],[32,192,192],[160,192,192],[96,64,64],[224,64,64],[96,192,64],[224,192,64],[96,64,192],[224,64,192],[96,192,192],[224,192,192],[0,32,0],[128,32,0],[0,160,0],[128,160,0],[0,32,128],[128,32,128],[0,160,128],[128,160,128],[64,32,0],[192,32,0],[64,160,0],[192,160,0],[64,32,128],[192,32,128],[64,160,128],[192,160,128],[0,96,0],[128,96,0],[0,224,0],[128,224,0],[0,96,128],[128,96,128],[0,224,128],[128,224,128],[64,96,0],[192,96,0],[64,224,0],[192,224,0],[64,96,128],[192,96,128],[64,224,128],[192,224,128],[0,32,64],[128,32,64],[0,160,64],[128,160,64],[0,32,192],[128,32,192],[0,160,192],[128,160,192],[64,32,64],[192,32,64],[64,160,64],[192,160,64],[64,32,192],[192,32,192],[64,160,192],[192,160,192],[0,96,64],[128,96,64],[0,224,64],[128,224,64],[0,96,192],[128,96,192],[0,224,192],[128,224,192],[64,96,64],[192,96,64],[64,224,64],[192,224,64],[64,96,192],[192,96,192],[64,224,192],[192,224,192],[32,32,0],[160,32,0],[32,160,0],[160,160,0],[32,32,128],[160,32,128],[32,160,128],[160,160,128],[96,32,0],[224,32,0],[96,160,0],[224,160,0],[96,32,128],[224,32,128],[96,160,128],[224,160,128],[32,96,0],[160,96,0],[32,224,0],[160,224,0],[32,96,128],[160,96,128],[32,224,128],[160,224,128],[96,96,0],[224,96,0],[96,224,0],[224,224,0],[96,96,128],[224,96,128],[96,224,128],[224,224,128],[32,32,64],[160,32,64],[32,160,64],[160,160,64],[32,32,192],[160,32,192],[32,160,192],[160,160,192],[96,32,64],[224,32,64],[96,160,64],[224,160,64],[96,32,192],[224,32,192],[96,160,192],[224,160,192],[32,96,64],[160,96,64],[32,224,64],[160,224,64],[32,96,192],[160,96,192],[32,224,192],[160,224,192],[96,96,64],[224,96,64],[96,224,64],[224,224,64],[96,96,192],[224,96,192],[96,224,192],[224,224,192]],Oe=["background","aeroplane","bicycle","bird","boat","bottle","bus","car","cat","chair","cow","dining table","dog","horse","motorbike","person","potted plant","sheep","sofa","train","TV"],ve=["road","sidewalk","building","wall","fence","pole","traffic light","traffic sign","vegetation","terrain","sky","person","rider","car","truck","bus","train","motorcycle","bicycle"],ke=["background","wall","building","sky","floor","tree","ceiling","road","bed","windowpane","grass","cabinet","sidewalk","person","earth","door","table","mountain","plant","curtain","chair","car","water","painting","sofa","shelf","house","sea","mirror","rug","field","armchair","seat","fence","desk","rock","wardrobe","lamp","bathtub","railing","cushion","base","box","column","signboard","chest","counter","sand","sink","skyscraper","fireplace","refrigerator","grandstand","path","stairs","runway","case","pool","pillow","screen","stairway","river","bridge","bookcase","blind","coffee","toilet","flower","book","hill","bench","countertop","stove","palm","kitchen","computer","swivel","boat","bar","arcade","hovel","bus","towel","light","truck","tower","chandelier","awning","streetlight","booth","television","airplane","dirt","apparel","pole","land","bannister","escalator","ottoman","bottle","buffet","poster","stage","van","ship","fountain","conveyer","canopy","washer","plaything","swimming","stool","barrel","basket","waterfall","tent","bag","minibike","cradle","oven","ball","food","step","tank","trade","microwave","pot","animal","bicycle","lake","dishwasher","screen","blanket","sculpture","hood","sconce","vase","traffic","tray","ashcan","fan","pier","screen","plate","monitor","bulletin","shower","radiator","glass","clock","flag"];function Ie(e,t){return"https://tfhub.dev/tensorflow/tfjs-model/deeplab/"+(4===t?e+"/1/default/1/model.json":e+"/1/quantized/"+t+"/1/model.json")+"?tfjs-format=file"}function Ae(e,t,a,n){return xe(this,void 0,void 0,(function(){var s,p,i,m,u,c,d,l,y,h,f,g,b,N;return Te(this,(function(x){switch(x.label){case 0:if(e.length<t.length)throw new Error("The colormap must be expansive enough to encode each label. Aborting, since the given colormap has length "+e.length+", but there are "+t.length+" labels.");return s=a.shape,p=s[0],i=s[1],m=(0,r.c)([p,i,3],"int32"),[4,a.array()];case 1:for(u=x.sent(),c=new Set,d=0;d<p;++d)for(l=0;l<i;++l)N=u[d][l],c.add(N),m.set(e[N][0],d,l,0),m.set(e[N][1],d,l,1),m.set(e[N][2],d,l,2);return y=m.toTensor(),[4,(0,o.ct)(y,n)];case 2:for(h=x.sent(),(0,r.J)(y),f={},g=0,b=Array.from(c);g<b.length;g++)N=b[g],f[t[N]]=e[N];return[2,{legend:f,segmentationMap:h}]}}))}))}function Ee(e){return void 0===e&&(e={base:"pascal",quantizationBytes:2}),xe(this,void 0,void 0,(function(){var t;return Te(this,(function(a){switch(a.label){case 0:if(null==p)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e.base){if(-1===["pascal","cityscapes","ade20k"].indexOf(e.base))throw new Error("SemanticSegmentation cannot be constructed with an invalid base model "+e.base+". Try one of 'pascal', 'cityscapes' and 'ade20k'.");if(-1===[1,2,4].indexOf(e.quantizationBytes))throw new Error("Only quantization to 1, 2 or 4 bytes is supported.")}else if(!e.modelUrl)throw new Error("SemanticSegmentation can be constructed either by passing the weights URL or one of the supported base model names from 'pascal', 'cityscapes' and 'ade20k',together with the degree of quantization (either 1, 2 or 4).Aborting, since neither has been provided.");return[4,Ne(e.modelUrl||Ie(e.base,e.quantizationBytes))];case 1:return t=a.sent(),[2,new De(t,e.base)]}}))}))}var De=function(){function e(e,t){this.model=e,this.base=t}return e.prototype.predict=function(e){var t=this;return(0,r.I)((function(){var a=(0,r.d)(function(e){return(0,r.I)((function(){var t=e instanceof r.T?e:(0,o.cs)(e),a=t.shape,n=a[0],s=a[1],p=513/Math.max(s,n),i=Math.round(n*p),m=Math.round(s*p);return(0,o.ad)(o.c9.resizeBilinear(t,[i,m]))}))}(e),"int32");return(0,o.bE)(t.model.execute(a))}))},e.prototype.segment=function(e,t){return void 0===t&&(t={}),xe(this,void 0,void 0,(function(){var a,n,s,o,p,i,m,u,c,d,l=this;return Te(this,(function(y){switch(y.label){case 0:if(!(t.colormap&&t.labels||this.base))throw new Error("Calling the 'segment' method requires either the 'base' attribute to be defined (e.g. 'pascal', 'cityscapes' or'ade20k'), or 'colormap' and 'labels' options to be set. Aborting, since neither has been provided.");return t.colormap&&t.labels||(t.colormap=function(e){if("pascal"===e)return we;if("ade20k"===e)return Se;if("cityscapes"===e)return _e;throw new Error("SemanticSegmentation cannot be constructed with an invalid base model "+e+". Try one of 'pascal', 'cityscapes' and 'ade20k'.")}(this.base),t.labels=function(e){if("pascal"===e)return Oe;if("ade20k"===e)return ke;if("cityscapes"===e)return ve;throw new Error("SemanticSegmentation cannot be constructed with an invalid base model "+e+". Try one of 'pascal', 'cityscapes' and 'ade20k'.")}(this.base)),a=t.colormap,n=t.labels,s=t.canvas,o=(0,r.I)((function(){return l.predict(e)})),p=o.shape,i=p[0],m=p[1],[4,Ae(a,n,o,s)];case 1:return u=y.sent(),c=u.legend,d=u.segmentationMap,(0,r.J)(o),[2,{legend:c,height:i,width:m,segmentationMap:d}]}}))}))},e.prototype.dispose=function(){return xe(this,void 0,void 0,(function(){return Te(this,(function(e){return this.model&&this.model.dispose(),[2]}))}))},e}()}}]);